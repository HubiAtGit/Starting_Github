[
  {
    "objectID": "LOGO.html",
    "href": "LOGO.html",
    "title": "LOGO-Versions",
    "section": "",
    "text": "Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Title\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\nDate\n\n\nTitle\n\n\nAuthor\n\n\n\n\n\n\nApr 15, 2025\n\n\nLogo with Gimmicks\n\n\nHubert Baechli\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Starting_Github",
    "section": "",
    "text": "Logo\nGoal: Programming a simple language with R\nLogo goes back much earlier than the Apple II, it was developed in 1967 by Cynthia Solomon, Wally Feurzig, and Seymour Papert. That’s five years before C and 24 years before Python! The three worked at Bolt, Beranek, and Newman (BBN), famous for all kinds of other computing history. BBN built the first Interface Message Processors (early routers) in 1968 for the ARPANET, which would evolve into the modern internet. …learn more"
  },
  {
    "objectID": "Classmates/template.html",
    "href": "Classmates/template.html",
    "title": "Git-Account",
    "section": "",
    "text": "here()\n\n[1] \"C:/Hubi/03_UZH/TutorJob/Starting_Github\""
  },
  {
    "objectID": "Classmates/template.html#your-local-clone-is-here",
    "href": "Classmates/template.html#your-local-clone-is-here",
    "title": "Git-Account",
    "section": "",
    "text": "here()\n\n[1] \"C:/Hubi/03_UZH/TutorJob/Starting_Github\""
  },
  {
    "objectID": "Classmates/chiaraschmidiger.html",
    "href": "Classmates/chiaraschmidiger.html",
    "title": "chiaraschmi",
    "section": "",
    "text": "here()\n\n[1] \"C:/Hubi/03_UZH/TutorJob/Starting_Github\""
  },
  {
    "objectID": "Classmates/chiaraschmidiger.html#your-local-clone-is-here",
    "href": "Classmates/chiaraschmidiger.html#your-local-clone-is-here",
    "title": "chiaraschmi",
    "section": "",
    "text": "here()\n\n[1] \"C:/Hubi/03_UZH/TutorJob/Starting_Github\""
  },
  {
    "objectID": "Classmates/HubiAtGit.html",
    "href": "Classmates/HubiAtGit.html",
    "title": "HubiAtGit",
    "section": "",
    "text": "here()\n\n[1] \"C:/Hubi/03_UZH/TutorJob/Starting_Github\""
  },
  {
    "objectID": "Classmates/HubiAtGit.html#your-local-clone-is-here",
    "href": "Classmates/HubiAtGit.html#your-local-clone-is-here",
    "title": "HubiAtGit",
    "section": "",
    "text": "here()\n\n[1] \"C:/Hubi/03_UZH/TutorJob/Starting_Github\""
  },
  {
    "objectID": "Classmates.html",
    "href": "Classmates.html",
    "title": "Classmates",
    "section": "",
    "text": "Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Title\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\nDate\n\n\nTitle\n\n\nAuthor\n\n\n\n\n\n\n \n\n\nGit-Account\n\n\n \n\n\n\n\nApr 8, 2025\n\n\nHubiAtGit\n\n\nHubert Bächli\n\n\n\n\nApr 9, 2025\n\n\nchiaraschmi\n\n\nChiara Schmidiger\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "LOGO/Hubi_Logo_V3.14.html",
    "href": "LOGO/Hubi_Logo_V3.14.html",
    "title": "Logo with Gimmicks",
    "section": "",
    "text": "Goal: Programming a simple language with R\nLogo goes back much earlier than the Apple II, it was developed in 1967 by Cynthia Solomon, Wally Feurzig, and Seymour Papert. That’s five years before C and 24 years before Python! The three worked at Bolt, Beranek, and Newman (BBN), famous for all kinds of other computing history. BBN built the first Interface Message Processors (early routers) in 1968 for the ARPANET, which would evolve into the modern internet. …learn more\n\n\nImplementing the basic commands see “Hello Turtle”\n\n\nClear the screen and initializing the field\n\nCLEARSCREEN &lt;- function (data) {\n  data &lt;- new_field(5)\n}\n\n\nCS &lt;- function (data) {\n  CLEARSCREEN(data)\n}\n\n\n\n\nDon’t show the turtle cursor.\n\nHIDETURTLE &lt;- function (data) {\n  data$turtle &lt;- FALSE\n  data &lt;- record_path(data, turtle = data$turtle)\n  data\n}\n\n\nHT &lt;- function (data) {\n  HIDETURTLE(data)\n}\n\n\n\n\nShow the turtle cursor.\n\nSHOWTURTLE &lt;- function (data) {\n  data$turtle &lt;- TRUE\n  data &lt;- record_path(data, turtle = data$turtle)\n  data\n}\n\n\nST &lt;- function (data) {\n  SHOWTURTLE(data)\n}\n\n\n\n\nMove forward steps.\n\nFORWARD &lt;- function (step, data) {\n  angle &lt;- data$path$rad[data$pos] \n  x0 &lt;- data$path$x[data$pos]\n  y0 &lt;- data$path$y[data$pos]\n  \n  max_step &lt;- 1\n  n_step &lt;- abs(step)%/%(max_step * 1.5) + 1\n  Seq0 &lt;- seq(from = 0, to = 1, by = 1/n_step)\n  Seq0 &lt;- Seq0[-1]\n  steps &lt;- qbeta(Seq0, shape1 = 0.15, shape2 = 0.2)\n  steps &lt;- steps * step\n  \n  x1 &lt;- x0 + cos(angle) * steps\n  y1 &lt;- y0 + sin(angle) * steps\n  data &lt;- record_path(data,  x = x1, y = y1, \n                      path_color = data$path_color)\n  data\n}\n\n\nFD &lt;- function (steps, data) {\n  FORWARD(steps, data)\n}\n\n\n\n\nMove back steps.\n\nBACK &lt;- function (steps, data) {\n  FORWARD(-steps, data)\n}\n\n\nBK &lt;- function (steps, data) {\n  BACK(steps, data)\n}\n\n\n\n\nTurn left this many degrees. Negative degrees work too, they’ll turn it right.\n\nLEFT &lt;- function (degs, data) {\n  data$heading &lt;- data$heading + degs\n  data &lt;- record_path(data, rad = data$heading * pi / 180)\n  data\n}\n\n\nLT &lt;- function (degs, data) {\n  LEFT(degs, data)\n}\n\n\n\n\nTurn right this many degrees.\n\nRIGHT &lt;- function (degs, data) {\n  LEFT(-degs, data)\n}\n\n\nRT &lt;- function (degs, data) {\n  RIGHT(degs, data)\n}\n\n\n\n\nTurn to an absolute heading of degrees.\n\nSETHEADING &lt;- function (deg, data) {\n  data$heading &lt;- deg\n  data &lt;- record_path(data, rad = data$heading * pi / 180)\n  data\n}\n\n\nSH &lt;- function (deg, data) {\n  SETHEADING(deg, data)\n}\n\n\n\n\nSet the position to x, y coordinates. These are Cartesian, so 0,0 is the middle of the screen.\n\nSETPOS &lt;- function (x1, y1, data) {\n  data &lt;- record_path(data, x = x1, y = y1, \n                      path_color = \"transparent\")\n  data\n}\n\n\nSP &lt;- function (x1, y1, data) {\n  SETPOS(x1, y1, data)\n}\n\n\n\n\nMove back to the home position.\n\nHOME &lt;- function (data) {\n  SETPOS(x1 = 0, y1 = 0, data)\n}\n\n\n\n\nSet the horizontal position to x.\n\nSETPOSX &lt;- function (x1, data) {\n  SETPOS(x1, y1 = data$path$y[data$pos], data)\n}\n\n\nSPX &lt;- function (x1, data) {\n  SETPOSX(x1, data)\n}\n\n\n\n\nSet the vertical position to y.\n\nSETPOSY &lt;- function (y1, data) {\n  SETPOS(x1 = data$path$x[data$pos], y1, data)\n}\n\n\nSPY &lt;- function (y1, data) {\n  SETPOSY(y1, data)\n}\n\n\n\n\n\n\n\n\nSETPATHCOLOR &lt;- function (path_color, data) {\n  data$path_color &lt;- path_color\n  data &lt;- record_path(data, path_color = data$path_color)\n  data\n}\n\n\nSPC &lt;- function (path_color, data) {\n  SETPATHCOLOR(path_color, data)\n}\n\n\n\n\n\nSETTURTLECOLOR &lt;- function (turtle_color, data) {\n  data$turtle_color &lt;- turtle_color\n  data &lt;- record_path(data, turtle_color = data$turtle_color)\n  data\n}\n\n\nSTC &lt;- function (turtle_color, data) {\n  SETTURTLECOLOR(turtle_color, data)\n}\n\n\n\n\n\nSETNEWCHUNK &lt;- function (data) {\n  data$chunk &lt;- data$chunk + 1\n  data &lt;- record_path(data, chunk = data$chunk)\n  data\n}\n\n\nSNC &lt;- function (data) {\n  SETNEWCHUNK(data)\n}\n\n\n\n\n\nUNDOCHUNK &lt;- function (data) {\n  last_chunk &lt;- max(data$path$chunk)\n  if (last_chunk &gt; 2) {\n    data$path &lt;- data$path[data$path$chunk != last_chunk,]\n  } else {\n    data &lt;- CLEARSCREEN(data) \n    data &lt;- REPLOT(data)\n    return(data)\n  }\n  \n  data$chunk &lt;- max(data$path$chunk)\n  data$pos &lt;- nrow(data$path)\n  data$heading &lt;- data$path$rad[data$pos] * 180 / pi \n  data$turtle &lt;- data$path$turtle[data$pos]\n  data$turtle_color &lt;- data$path$turtle_color[data$pos]\n  \n  last_pos &lt;- data$pos\n  while (data$path$path_color[last_pos] == \"transparent\" && last_pos &gt; 0) {\n    last_pos &lt;- last_pos - 1\n  }\n  if (last_pos == 1) {\n    data$path_color &lt;- \"blue\"\n  } else {\n    data$path_color &lt;- data$path$path_color[last_pos]\n  }\n  \n  data &lt;- REPLOT(data)\n  \n  data\n}\n\n\nUNDO &lt;- function (data) {\n  UNDOCHUNK(data)\n}\n\n\n\n\n\nSETSPEED &lt;- function (speed, data) {\n  speed &lt;- pmax(speed, 1)\n  speed &lt;- round(speed)\n  data$speed &lt;- speed\n  #data &lt;- REPLOT(data)\n  data\n}\n\n\nSPEED &lt;- function (speed, data) {\n  SETSPEED(speed, data)\n}\n\n\n\n\n\nREPLOT &lt;- function (data, chunk = FALSE) {\n  PLOT(data, chunk)\n}\n\n\n\n\n\nSAVEPATH &lt;- function (name, data) {\n  name_raw &lt;- paste0(name, \".rds\")\n  name_gif &lt;- paste0(name, \".gif\")\n  data &lt;- REPLOT(data)\n  saveRDS(data$path, here(\"LOGO\", name_raw))\n  file.copy(from = here(\"LOGO\", \"temp\", \"output.gif\"), \n            to = here(\"LOGO\", name_gif), \n            overwrite = TRUE)\n  data\n}\n\n\nSAVE &lt;- function (name, data) {\n  SAVEPATH(name, data)\n}\n\n\n\n\n\nQUITLOGO &lt;- function (data) {\n  suppressWarnings(unlink(here(\"LOGO\", \"temp\"), recursive = TRUE))\n  data &lt;- NULL\n  data\n}\n\n\nQUIT &lt;- function (data) {\n  QUITLOGO(data)\n}\n\n\n\n\n\n\n\n\nclean_prompt &lt;- function (Prompt) {\n  Prompt &lt;- gsub(\"([^a-zA-Z0-9])\", \" \\\\1 \", Prompt)\n  Prompt &lt;- gsub(\"\\\\s+\", \" \", Prompt)\n  Prompt &lt;- gsub(\"-\\\\s+(?=\\\\d)\", \"-\", Prompt, perl = TRUE)\n  Prompt &lt;- gsub(\"\\\\s*\\\\.\\\\s*\", \".\", Prompt)\n  Prompt &lt;- gsub(\"\\\\s*_\\\\s*\", \"_\", Prompt)\n  Prompt &lt;- trimws(Prompt)\n  Prompt\n}\n\n\n\n\n\nbreakup_String &lt;- function(String) {\n  cl_String &lt;- clean_prompt(String)\n  split_String &lt;- strsplit(cl_String, \" \")[[1]]\n  df &lt;- data.frame(Code = split_String)\n  \n  n_func &lt;- 0\n  df$ID_Func &lt;- rep(0, nrow(df))\n  \n  n_par &lt;- 0\n  df$ID_Par &lt;- rep(0, nrow(df))\n  \n  ID &lt;- 1\n  df$ID_Repeat &lt;- rep(0, nrow(df))\n  \n  brakets &lt;- data.frame(ID = ID,\n                        Status = TRUE,\n                        n = 1)\n  \n  level &lt;- brakets$ID[max(which(brakets$Status == TRUE))]\n  \n  df$n_Repeat &lt;- rep(1, nrow(df))\n  \n  is_par_braket &lt;- FALSE\n  \n  i &lt;- 1\n  imax &lt;- nrow(df) + 1\n  \n  while ( i &lt; imax ) {\n    \n    if (df$Code[i] == \"[\") {\n        n_par &lt;- n_par + 1\n        is_par_braket &lt;- TRUE\n        i &lt;- i + 1\n        next\n    }\n    \n    if (is_par_braket) {\n      \n      if (df$Code[i] == \"]\") {\n        is_par_braket &lt;- FALSE\n        i &lt;- i + 1\n        next\n      }\n      \n      if ( !grepl(\"[A-Za-z]\", df$Code[i])) {\n        df$ID_Func[i] &lt;- n_func\n        df$ID_Par[i] &lt;- n_par\n        df$ID_Repeat[i] &lt;- brakets$ID[brakets$ID == level]\n        df$n_Repeat[i] &lt;- brakets$n[brakets$ID == level]\n        i &lt;- i + 1\n        next\n      } else {\n        inLower &lt;- tolower(df$Code[i])\n        if (inLower == \"n\") {\n          df$Code[i] &lt;- paste0(\"(\",inLower,\")\")\n        } else if (inLower %in% colors()) {\n          df$Code[i] &lt;- paste0(shQuote(inLower))\n        } else if (exists(inLower)) {\n          df$Code[i] &lt;- inLower\n        }  else {\n          df$Code[i] &lt;- paste0(shQuote(df$Code[i]))\n        }\n        df$ID_Func[i] &lt;- n_func\n        df$ID_Par[i] &lt;- n_par\n        df$ID_Repeat[i] &lt;- brakets$ID[brakets$ID == level]\n        df$n_Repeat[i] &lt;- brakets$n[brakets$ID == level]\n        i &lt;- i + 1\n        next\n      }\n      \n    } else {\n      \n      if (df$Code[i] == \"]\") {\n      brakets$Status[brakets$ID == level] &lt;- FALSE\n      level &lt;- brakets$ID[max(which(brakets$Status == TRUE))]\n      i &lt;- i + 1\n      next\n      }\n      \n      if ( !grepl(\"[A-Za-z]\", df$Code[i]) ) {\n        n_par &lt;- n_par + 1\n        df$ID_Func[i] &lt;- n_func\n        df$ID_Par[i] &lt;- n_par\n        df$ID_Repeat[i] &lt;- brakets$ID[brakets$ID == level]\n        df$n_Repeat[i] &lt;- brakets$n[brakets$ID == level]\n        i &lt;- i + 1\n        next\n      } else {\n        inCaps &lt;- toupper(df$Code[i])\n        \n        is_LOGO_func &lt;- exists(inCaps) && is.function(get(inCaps))\n        if (is_LOGO_func) {\n          n_func &lt;- n_func + 1\n          df$Code[i] &lt;- inCaps\n        }\n      \n        is_repeat &lt;- inCaps == \"REPEAT\"\n        if (is_repeat) {\n          n_func &lt;- n_func + 1\n          ID &lt;- ID + 1\n          i = i + 2\n          df$Code[i] &lt;- inCaps\n          brakets &lt;- rbind(brakets,\n                           data.frame(ID = ID, \n                                      Status = TRUE, \n                                      n = round(as.numeric(df$Code[i - 1]))))\n          level &lt;- brakets$ID[max(which(brakets$Status == TRUE))]\n        }\n        df$ID_Func[i] &lt;- n_func\n        df$ID_Repeat[i] &lt;- brakets$ID[brakets$ID == level]\n        df$n_Repeat[i] &lt;- brakets$n[brakets$ID == level]\n        i &lt;- i + 1\n        next\n      }\n    }\n\n  }\n  return(df[df$ID_Func != 0,])\n}\n\n\nCodeLine &lt;- \"CS SP [-pi/5] [-Sin(PI/2)/2] sPc [black]\"\ncl_splited &lt;-breakup_String(CodeLine)\ncl_splited\n\n      Code ID_Func ID_Par ID_Repeat n_Repeat\n1       CS       1      0         1        1\n2       SP       2      0         1        1\n4        -       2      1         1        1\n5       pi       2      1         1        1\n6        /       2      1         1        1\n7        5       2      1         1        1\n10       -       2      2         1        1\n11     sin       2      2         1        1\n12       (       2      2         1        1\n13      pi       2      2         1        1\n14       /       2      2         1        1\n15       2       2      2         1        1\n16       )       2      2         1        1\n17       /       2      2         1        1\n18       2       2      2         1        1\n20     SPC       3      0         1        1\n22 \"black\"       3      3         1        1\n\n\n\n\n\n\ncreate_Calls &lt;- function (splited) {\n  Calls &lt;- splited %&gt;%\n    group_by(ID_Func, ID_Par) %&gt;%\n    mutate(Func_Par = ifelse(ID_Par &gt; 0,1,0),\n           Code = ifelse(first(ID_Par) &gt; 0, \n                         paste0(Code, collapse = \"\"),\n                         Code)) %&gt;%\n    ungroup() %&gt;%\n    distinct(Code, ID_Func, ID_Par, Func_Par, .keep_all = TRUE) %&gt;%\n    \n    group_by(ID_Func, Func_Par) %&gt;%\n    mutate(Code = ifelse(first(Func_Par) &gt; 0, \n                         paste0(c(Code,\"data)\"), collapse = \",\"), \n                         Code)) %&gt;%\n    ungroup() %&gt;%\n    distinct(Code, ID_Func, Func_Par, .keep_all = TRUE) %&gt;%\n  \n    group_by(ID_Func) %&gt;%\n    mutate(Code = ifelse(n() &gt; 1,\n                         paste0(Code, collapse = \"(\"),\n                         paste0(Code, \"(data)\"))) %&gt;%\n    ungroup() %&gt;%\n    distinct(Code, ID_Func, .keep_all = TRUE) %&gt;%\n    rename(Call = Code, ID = ID_Repeat, n = n_Repeat ) %&gt;%\n    select(Call,ID, n)\n  \n  if ( !any(grepl(\"^UN|SPEED|SAVE|QUIT\", Calls$Call)) ) {\n    first_call &lt;- data.frame(Call = \"SETNEWCHUNK(data)\", ID = 1, n = 1)\n    last_call &lt;- data.frame(Call = \"PLOT(data)\", ID = 1, n = 1)\n    Calls &lt;- rbind(first_call, Calls, last_call)\n  } \n  \n  Calls\n}\n\n\nCallshort &lt;- create_Calls(cl_splited)\nCallshort \n\n                         Call ID n\n1           SETNEWCHUNK(data)  1 1\n2                    CS(data)  1 1\n3 SP(-pi/5,-sin(pi/2)/2,data)  1 1\n4           SPC(\"black\",data)  1 1\n5                  PLOT(data)  1 1\n\n\n\n\n\n\nexpand_Repeats &lt;- function (Calls) {\n  IDmax &lt;- max(Calls$ID)\n  if (IDmax == 1) {\n    return(as.vector(Calls$Call))\n  } \n  while (IDmax &gt; 1){\n    \n    dfm &lt;- data.frame(\n      Call = character(),\n      ID = integer(),\n      n = integer(),\n      stringsAsFactors = FALSE\n      )\n    \n    rID &lt;- range(which(Calls$ID == IDmax))\n    n &lt;- Calls$n[rID[1]] \n    middle &lt;- (rID[1] + 1):rID[2]\n    \n    for (i in 1:n) {\n      dfm_sub &lt;- Calls[middle, ] %&gt;%\n        mutate(Call = gsub(\"\\\\(n\\\\)\", i, Call))\n      dfm &lt;- rbind(dfm,dfm_sub)\n      }\n    dfm$ID &lt;- Calls$ID[rID[1]-1]\n    dfm$n &lt;- Calls$n[rID[1]-1]\n    \n    before &lt;- 1:(rID[1] - 1)\n    dfb &lt;- Calls[before, ]\n    \n    after &lt;- (rID[2] + 1):nrow(Calls)\n    dfa &lt;- Calls[after, ]\n    \n    Calls &lt;- rbind(dfb,dfm,dfa)\n    IDmax &lt;- max(Calls$ID)\n  }\n  return(as.vector(Calls$Call[Calls$Call != \"\"]))\n}\n\n\nCalls &lt;- expand_Repeats(Callshort)\nCalls\n\n[1] \"SETNEWCHUNK(data)\"           \"CS(data)\"                   \n[3] \"SP(-pi/5,-sin(pi/2)/2,data)\" \"SPC(\\\"black\\\",data)\"        \n[5] \"PLOT(data)\"                 \n\n\n\n\n\n\nrun_prompt &lt;- function (Prompt, data) {\n  Prompt_splited &lt;- breakup_String(Prompt)\n  Callshort &lt;- create_Calls(Prompt_splited)\n  Calls &lt;- expand_Repeats(Callshort)\n  for (i in 1:length(Calls)){\n    data &lt;- eval(parse(text = as.character(Calls[i])))\n    }\n  data\n}\n\n\n\n\n\n\n\nInitializing the game\n\nnew_field &lt;- function (size) {\n  dir_path &lt;- here(\"LOGO\",\"temp\")\n  chunk &lt;- 0\n  pos &lt;- 1\n  heading &lt;- 0\n  turtle &lt;- TRUE\n  turtle_color &lt;- \"red\"\n  path_color &lt;- \"blue\"\n  speed &lt;- 50\n  path &lt;- data.frame(chunk = 1,\n                     x = 0, y = 0, rad = 0, \n                     path_color = \"transparent\",\n                     turtle = turtle,\n                     turtle_color = turtle_color)\n  field &lt;- NULL\n  data &lt;- list(field_name = \"Logo\",\n               field_dir = file.path(dir_path),\n               size = abs(size),\n               chunk = chunk,\n               pos = pos,\n               heading = heading,\n               turtle = turtle,\n               turtle_color = turtle_color,\n               path_color = path_color,\n               speed = speed,\n               path = path)\n  data &lt;- SETNEWCHUNK(data)\n  data\n}\n\n\n\n\n\n record_path &lt;- function (data, \n                          chunk = NULL,\n                          x = NULL, \n                          y = NULL, \n                          rad = NULL, \n                          path_color = NULL, \n                          turtle = NULL,\n                          turtle_color = NULL) {\n   \n   temp &lt;- data$pos\n   n &lt;- max(lengths(list(chunk, x, y, rad, path_color, turtle, turtle_color)))\n   \n   template &lt;- data$path[temp, ]\n   newrows &lt;- template[rep(1, n), ]\n   \n   if (!is.null(chunk)) newrows$chunk &lt;- chunk\n   if (!is.null(x)) newrows$x &lt;- x\n   if (!is.null(y)) newrows$y &lt;- y\n   if (!is.null(rad)) newrows$rad &lt;- rad\n   if (!is.null(path_color)) newrows$path_color &lt;- path_color\n   if (!is.null(turtle)) newrows$turtle &lt;- turtle\n   if (!is.null(turtle_color)) newrows$turtle_color &lt;- turtle_color\n   \n   data$path &lt;- rbind(data$path, newrows)\n   rownames(data$path) &lt;- NULL\n   data$pos &lt;- nrow(data$path)\n   data\n}\n\n\n\n\n\n\n\n\nplot_field &lt;- function (data, stat = NULL) {\n  if(is.null(stat)) stat &lt;- nrow(data$path)\n  maxpath &lt;- ceiling(max(abs(data$path[1:stat,c(\"x\",\"y\")])) * 1.11)\n  data$size &lt;- max(c(data$size, maxpath))\n  png_name &lt;- here(data$field_dir, paste0(data$field_name, stat, \".png\"))\n  png(png_name, width = 600, height = 600, res = 150)\n  par(mar = c(0, 0, 0, 0),\n      xaxs = \"i\", yaxs = \"i\")\n  plot.new()\n  plot.window(xlim = c(-data$size, data$size),\n              ylim = c(-data$size, data$size),\n              asp = 1)\n  box()\n  data\n}\n\n\n\n\n\nplot_path &lt;- function (data, stat = NULL) {\n  if(is.null(stat)) stat &lt;- nrow(data$path)\n  if (stat &gt; 1) {\n     for (i in 2:stat) {\n       segments(x0 = data$path$x[i-1], y0 = data$path$y[i-1],\n                x1 = data$path$x[i], y1 = data$path$y[i],\n                col = data$path$path_color[i], lwd = 2)\n     }\n  }\n  data\n}\n\n\n\n\n\nplot_turtle &lt;- function (data, stat = NULL) {\n  if(is.null(stat)) stat &lt;- nrow(data$path)\n  show &lt;-  data$path$turtle[stat]\n  if (show) {\n    symbols(x = data$path$x[stat],\n        y = data$path$y[stat],\n        circles = 0.02 * data$size,\n        inches = FALSE,\n        fg = NA,\n        bg = data$path$turtle_color[stat],\n        add = TRUE)\n    arrow_length &lt;- 0.1 * data$size\n    angle &lt;- data$path$rad[stat]\n    arrows(data$path$x[stat],\n           data$path$y[stat],\n           data$path$x[stat] + cos(angle) * arrow_length,\n           data$path$y[stat] + sin(angle) * arrow_length,\n           col = data$path$turtle_color[stat],\n           code = 2,\n           length = 0.1,\n           angle = 20,\n           lwd = 2)\n  }\n  dev.off()\n  data\n}\n\n\n\n\n\nplot_stat &lt;- function (data, stat = NULL) {\n  if(is.null(stat)) stat &lt;- nrow(data$path)\n  data &lt;- plot_field(data, stat)\n  data &lt;- plot_path(data, stat)\n  data &lt;- plot_turtle(data, stat)\n}\n\n\n\n\n\nclear_png &lt;- function (data) {\n  png_files &lt;- list.files(path = data$field_dir, \n                          pattern = \"\\\\.png$\", \n                          full.names = TRUE)\n  file.remove(png_files)\n}\n\n\nsave_png &lt;- function (data, chunk) {\n  if (chunk) {\n    Range &lt;- range(which(data$path$chunk == max(data$chunk)))\n    rmin &lt;- max(2,Range[1])\n    rmax &lt;- Range[2]\n    } else {\n      rmin &lt;- 2\n      rmax &lt;- nrow(data$path)\n    }\n  step &lt;- data$speed/(rmax-rmin)\n  step &lt;- pmin(pmax(step, 1/100), 1)\n  Seq0 &lt;- seq(from = 0, to = 1, by = step)\n  plot_seq &lt;- qbeta(Seq0, shape1 = 0.15, shape2 = 0.2)\n  plot_seq &lt;- (rmax - rmin) * plot_seq + rmin\n  plot_seq &lt;- round(plot_seq)\n  plot_seq &lt;- unique(plot_seq)\n\n  for (i in plot_seq) {\n      plot_stat(data, stat = i)\n  }\n}\n\n\nPLOT &lt;- function (data, chunk = TRUE) {\n  clear_png(data)\n  save_png(data, chunk = chunk)\n  png_files &lt;- list.files(path = data$field_dir, \n                          pattern = \"\\\\.png$\", \n                          full.names = TRUE)\n  png_files &lt;- png_files[order(as.numeric(gsub(\"\\\\D\", \"\", png_files)))]\n  img_list &lt;- lapply(png_files, image_read) \n  animation &lt;- image_animate(image_join(img_list), \n                             fps = 10, , loop = 1,\n                             optimize = TRUE) \n  image_write(animation, here(\"LOGO\",\"temp\",\"Output.gif\"))\n  clear_png(data)\n  data\n}\n\n\n\n\n\n\nrun_LOGO &lt;- function (string) {\n  file_path &lt;- here(\"LOGO\",\"temp\",\"Logo.rds\")\n  if (!dir.exists(here(\"LOGO\",\"temp\"))) {\n    dir.create(here(\"LOGO\", \"temp\"), showWarnings = FALSE)\n    }\n  if (file.exists(file_path)) {\n    data &lt;- readRDS(file_path)\n    } else {\n      data &lt;- new_field(5)\n    }\n  data &lt;- run_prompt(string, data)\n  if (!is.null(data)) {\n    saveRDS(data, file_path)\n  }\n}"
  },
  {
    "objectID": "LOGO/Hubi_Logo_V3.14.html#basic-commands",
    "href": "LOGO/Hubi_Logo_V3.14.html#basic-commands",
    "title": "Logo with Gimmicks",
    "section": "",
    "text": "Implementing the basic commands see “Hello Turtle”\n\n\nClear the screen and initializing the field\n\nCLEARSCREEN &lt;- function (data) {\n  data &lt;- new_field(5)\n}\n\n\nCS &lt;- function (data) {\n  CLEARSCREEN(data)\n}\n\n\n\n\nDon’t show the turtle cursor.\n\nHIDETURTLE &lt;- function (data) {\n  data$turtle &lt;- FALSE\n  data &lt;- record_path(data, turtle = data$turtle)\n  data\n}\n\n\nHT &lt;- function (data) {\n  HIDETURTLE(data)\n}\n\n\n\n\nShow the turtle cursor.\n\nSHOWTURTLE &lt;- function (data) {\n  data$turtle &lt;- TRUE\n  data &lt;- record_path(data, turtle = data$turtle)\n  data\n}\n\n\nST &lt;- function (data) {\n  SHOWTURTLE(data)\n}\n\n\n\n\nMove forward steps.\n\nFORWARD &lt;- function (step, data) {\n  angle &lt;- data$path$rad[data$pos] \n  x0 &lt;- data$path$x[data$pos]\n  y0 &lt;- data$path$y[data$pos]\n  \n  max_step &lt;- 1\n  n_step &lt;- abs(step)%/%(max_step * 1.5) + 1\n  Seq0 &lt;- seq(from = 0, to = 1, by = 1/n_step)\n  Seq0 &lt;- Seq0[-1]\n  steps &lt;- qbeta(Seq0, shape1 = 0.15, shape2 = 0.2)\n  steps &lt;- steps * step\n  \n  x1 &lt;- x0 + cos(angle) * steps\n  y1 &lt;- y0 + sin(angle) * steps\n  data &lt;- record_path(data,  x = x1, y = y1, \n                      path_color = data$path_color)\n  data\n}\n\n\nFD &lt;- function (steps, data) {\n  FORWARD(steps, data)\n}\n\n\n\n\nMove back steps.\n\nBACK &lt;- function (steps, data) {\n  FORWARD(-steps, data)\n}\n\n\nBK &lt;- function (steps, data) {\n  BACK(steps, data)\n}\n\n\n\n\nTurn left this many degrees. Negative degrees work too, they’ll turn it right.\n\nLEFT &lt;- function (degs, data) {\n  data$heading &lt;- data$heading + degs\n  data &lt;- record_path(data, rad = data$heading * pi / 180)\n  data\n}\n\n\nLT &lt;- function (degs, data) {\n  LEFT(degs, data)\n}\n\n\n\n\nTurn right this many degrees.\n\nRIGHT &lt;- function (degs, data) {\n  LEFT(-degs, data)\n}\n\n\nRT &lt;- function (degs, data) {\n  RIGHT(degs, data)\n}\n\n\n\n\nTurn to an absolute heading of degrees.\n\nSETHEADING &lt;- function (deg, data) {\n  data$heading &lt;- deg\n  data &lt;- record_path(data, rad = data$heading * pi / 180)\n  data\n}\n\n\nSH &lt;- function (deg, data) {\n  SETHEADING(deg, data)\n}\n\n\n\n\nSet the position to x, y coordinates. These are Cartesian, so 0,0 is the middle of the screen.\n\nSETPOS &lt;- function (x1, y1, data) {\n  data &lt;- record_path(data, x = x1, y = y1, \n                      path_color = \"transparent\")\n  data\n}\n\n\nSP &lt;- function (x1, y1, data) {\n  SETPOS(x1, y1, data)\n}\n\n\n\n\nMove back to the home position.\n\nHOME &lt;- function (data) {\n  SETPOS(x1 = 0, y1 = 0, data)\n}\n\n\n\n\nSet the horizontal position to x.\n\nSETPOSX &lt;- function (x1, data) {\n  SETPOS(x1, y1 = data$path$y[data$pos], data)\n}\n\n\nSPX &lt;- function (x1, data) {\n  SETPOSX(x1, data)\n}\n\n\n\n\nSet the vertical position to y.\n\nSETPOSY &lt;- function (y1, data) {\n  SETPOS(x1 = data$path$x[data$pos], y1, data)\n}\n\n\nSPY &lt;- function (y1, data) {\n  SETPOSY(y1, data)\n}"
  },
  {
    "objectID": "LOGO/Hubi_Logo_V3.14.html#gimmicks",
    "href": "LOGO/Hubi_Logo_V3.14.html#gimmicks",
    "title": "Logo with Gimmicks",
    "section": "",
    "text": "SETPATHCOLOR &lt;- function (path_color, data) {\n  data$path_color &lt;- path_color\n  data &lt;- record_path(data, path_color = data$path_color)\n  data\n}\n\n\nSPC &lt;- function (path_color, data) {\n  SETPATHCOLOR(path_color, data)\n}\n\n\n\n\n\nSETTURTLECOLOR &lt;- function (turtle_color, data) {\n  data$turtle_color &lt;- turtle_color\n  data &lt;- record_path(data, turtle_color = data$turtle_color)\n  data\n}\n\n\nSTC &lt;- function (turtle_color, data) {\n  SETTURTLECOLOR(turtle_color, data)\n}\n\n\n\n\n\nSETNEWCHUNK &lt;- function (data) {\n  data$chunk &lt;- data$chunk + 1\n  data &lt;- record_path(data, chunk = data$chunk)\n  data\n}\n\n\nSNC &lt;- function (data) {\n  SETNEWCHUNK(data)\n}\n\n\n\n\n\nUNDOCHUNK &lt;- function (data) {\n  last_chunk &lt;- max(data$path$chunk)\n  if (last_chunk &gt; 2) {\n    data$path &lt;- data$path[data$path$chunk != last_chunk,]\n  } else {\n    data &lt;- CLEARSCREEN(data) \n    data &lt;- REPLOT(data)\n    return(data)\n  }\n  \n  data$chunk &lt;- max(data$path$chunk)\n  data$pos &lt;- nrow(data$path)\n  data$heading &lt;- data$path$rad[data$pos] * 180 / pi \n  data$turtle &lt;- data$path$turtle[data$pos]\n  data$turtle_color &lt;- data$path$turtle_color[data$pos]\n  \n  last_pos &lt;- data$pos\n  while (data$path$path_color[last_pos] == \"transparent\" && last_pos &gt; 0) {\n    last_pos &lt;- last_pos - 1\n  }\n  if (last_pos == 1) {\n    data$path_color &lt;- \"blue\"\n  } else {\n    data$path_color &lt;- data$path$path_color[last_pos]\n  }\n  \n  data &lt;- REPLOT(data)\n  \n  data\n}\n\n\nUNDO &lt;- function (data) {\n  UNDOCHUNK(data)\n}\n\n\n\n\n\nSETSPEED &lt;- function (speed, data) {\n  speed &lt;- pmax(speed, 1)\n  speed &lt;- round(speed)\n  data$speed &lt;- speed\n  #data &lt;- REPLOT(data)\n  data\n}\n\n\nSPEED &lt;- function (speed, data) {\n  SETSPEED(speed, data)\n}\n\n\n\n\n\nREPLOT &lt;- function (data, chunk = FALSE) {\n  PLOT(data, chunk)\n}\n\n\n\n\n\nSAVEPATH &lt;- function (name, data) {\n  name_raw &lt;- paste0(name, \".rds\")\n  name_gif &lt;- paste0(name, \".gif\")\n  data &lt;- REPLOT(data)\n  saveRDS(data$path, here(\"LOGO\", name_raw))\n  file.copy(from = here(\"LOGO\", \"temp\", \"output.gif\"), \n            to = here(\"LOGO\", name_gif), \n            overwrite = TRUE)\n  data\n}\n\n\nSAVE &lt;- function (name, data) {\n  SAVEPATH(name, data)\n}\n\n\n\n\n\nQUITLOGO &lt;- function (data) {\n  suppressWarnings(unlink(here(\"LOGO\", \"temp\"), recursive = TRUE))\n  data &lt;- NULL\n  data\n}\n\n\nQUIT &lt;- function (data) {\n  QUITLOGO(data)\n}"
  },
  {
    "objectID": "LOGO/Hubi_Logo_V3.14.html#parsing-prompts",
    "href": "LOGO/Hubi_Logo_V3.14.html#parsing-prompts",
    "title": "Logo with Gimmicks",
    "section": "",
    "text": "clean_prompt &lt;- function (Prompt) {\n  Prompt &lt;- gsub(\"([^a-zA-Z0-9])\", \" \\\\1 \", Prompt)\n  Prompt &lt;- gsub(\"\\\\s+\", \" \", Prompt)\n  Prompt &lt;- gsub(\"-\\\\s+(?=\\\\d)\", \"-\", Prompt, perl = TRUE)\n  Prompt &lt;- gsub(\"\\\\s*\\\\.\\\\s*\", \".\", Prompt)\n  Prompt &lt;- gsub(\"\\\\s*_\\\\s*\", \"_\", Prompt)\n  Prompt &lt;- trimws(Prompt)\n  Prompt\n}\n\n\n\n\n\nbreakup_String &lt;- function(String) {\n  cl_String &lt;- clean_prompt(String)\n  split_String &lt;- strsplit(cl_String, \" \")[[1]]\n  df &lt;- data.frame(Code = split_String)\n  \n  n_func &lt;- 0\n  df$ID_Func &lt;- rep(0, nrow(df))\n  \n  n_par &lt;- 0\n  df$ID_Par &lt;- rep(0, nrow(df))\n  \n  ID &lt;- 1\n  df$ID_Repeat &lt;- rep(0, nrow(df))\n  \n  brakets &lt;- data.frame(ID = ID,\n                        Status = TRUE,\n                        n = 1)\n  \n  level &lt;- brakets$ID[max(which(brakets$Status == TRUE))]\n  \n  df$n_Repeat &lt;- rep(1, nrow(df))\n  \n  is_par_braket &lt;- FALSE\n  \n  i &lt;- 1\n  imax &lt;- nrow(df) + 1\n  \n  while ( i &lt; imax ) {\n    \n    if (df$Code[i] == \"[\") {\n        n_par &lt;- n_par + 1\n        is_par_braket &lt;- TRUE\n        i &lt;- i + 1\n        next\n    }\n    \n    if (is_par_braket) {\n      \n      if (df$Code[i] == \"]\") {\n        is_par_braket &lt;- FALSE\n        i &lt;- i + 1\n        next\n      }\n      \n      if ( !grepl(\"[A-Za-z]\", df$Code[i])) {\n        df$ID_Func[i] &lt;- n_func\n        df$ID_Par[i] &lt;- n_par\n        df$ID_Repeat[i] &lt;- brakets$ID[brakets$ID == level]\n        df$n_Repeat[i] &lt;- brakets$n[brakets$ID == level]\n        i &lt;- i + 1\n        next\n      } else {\n        inLower &lt;- tolower(df$Code[i])\n        if (inLower == \"n\") {\n          df$Code[i] &lt;- paste0(\"(\",inLower,\")\")\n        } else if (inLower %in% colors()) {\n          df$Code[i] &lt;- paste0(shQuote(inLower))\n        } else if (exists(inLower)) {\n          df$Code[i] &lt;- inLower\n        }  else {\n          df$Code[i] &lt;- paste0(shQuote(df$Code[i]))\n        }\n        df$ID_Func[i] &lt;- n_func\n        df$ID_Par[i] &lt;- n_par\n        df$ID_Repeat[i] &lt;- brakets$ID[brakets$ID == level]\n        df$n_Repeat[i] &lt;- brakets$n[brakets$ID == level]\n        i &lt;- i + 1\n        next\n      }\n      \n    } else {\n      \n      if (df$Code[i] == \"]\") {\n      brakets$Status[brakets$ID == level] &lt;- FALSE\n      level &lt;- brakets$ID[max(which(brakets$Status == TRUE))]\n      i &lt;- i + 1\n      next\n      }\n      \n      if ( !grepl(\"[A-Za-z]\", df$Code[i]) ) {\n        n_par &lt;- n_par + 1\n        df$ID_Func[i] &lt;- n_func\n        df$ID_Par[i] &lt;- n_par\n        df$ID_Repeat[i] &lt;- brakets$ID[brakets$ID == level]\n        df$n_Repeat[i] &lt;- brakets$n[brakets$ID == level]\n        i &lt;- i + 1\n        next\n      } else {\n        inCaps &lt;- toupper(df$Code[i])\n        \n        is_LOGO_func &lt;- exists(inCaps) && is.function(get(inCaps))\n        if (is_LOGO_func) {\n          n_func &lt;- n_func + 1\n          df$Code[i] &lt;- inCaps\n        }\n      \n        is_repeat &lt;- inCaps == \"REPEAT\"\n        if (is_repeat) {\n          n_func &lt;- n_func + 1\n          ID &lt;- ID + 1\n          i = i + 2\n          df$Code[i] &lt;- inCaps\n          brakets &lt;- rbind(brakets,\n                           data.frame(ID = ID, \n                                      Status = TRUE, \n                                      n = round(as.numeric(df$Code[i - 1]))))\n          level &lt;- brakets$ID[max(which(brakets$Status == TRUE))]\n        }\n        df$ID_Func[i] &lt;- n_func\n        df$ID_Repeat[i] &lt;- brakets$ID[brakets$ID == level]\n        df$n_Repeat[i] &lt;- brakets$n[brakets$ID == level]\n        i &lt;- i + 1\n        next\n      }\n    }\n\n  }\n  return(df[df$ID_Func != 0,])\n}\n\n\nCodeLine &lt;- \"CS SP [-pi/5] [-Sin(PI/2)/2] sPc [black]\"\ncl_splited &lt;-breakup_String(CodeLine)\ncl_splited\n\n      Code ID_Func ID_Par ID_Repeat n_Repeat\n1       CS       1      0         1        1\n2       SP       2      0         1        1\n4        -       2      1         1        1\n5       pi       2      1         1        1\n6        /       2      1         1        1\n7        5       2      1         1        1\n10       -       2      2         1        1\n11     sin       2      2         1        1\n12       (       2      2         1        1\n13      pi       2      2         1        1\n14       /       2      2         1        1\n15       2       2      2         1        1\n16       )       2      2         1        1\n17       /       2      2         1        1\n18       2       2      2         1        1\n20     SPC       3      0         1        1\n22 \"black\"       3      3         1        1\n\n\n\n\n\n\ncreate_Calls &lt;- function (splited) {\n  Calls &lt;- splited %&gt;%\n    group_by(ID_Func, ID_Par) %&gt;%\n    mutate(Func_Par = ifelse(ID_Par &gt; 0,1,0),\n           Code = ifelse(first(ID_Par) &gt; 0, \n                         paste0(Code, collapse = \"\"),\n                         Code)) %&gt;%\n    ungroup() %&gt;%\n    distinct(Code, ID_Func, ID_Par, Func_Par, .keep_all = TRUE) %&gt;%\n    \n    group_by(ID_Func, Func_Par) %&gt;%\n    mutate(Code = ifelse(first(Func_Par) &gt; 0, \n                         paste0(c(Code,\"data)\"), collapse = \",\"), \n                         Code)) %&gt;%\n    ungroup() %&gt;%\n    distinct(Code, ID_Func, Func_Par, .keep_all = TRUE) %&gt;%\n  \n    group_by(ID_Func) %&gt;%\n    mutate(Code = ifelse(n() &gt; 1,\n                         paste0(Code, collapse = \"(\"),\n                         paste0(Code, \"(data)\"))) %&gt;%\n    ungroup() %&gt;%\n    distinct(Code, ID_Func, .keep_all = TRUE) %&gt;%\n    rename(Call = Code, ID = ID_Repeat, n = n_Repeat ) %&gt;%\n    select(Call,ID, n)\n  \n  if ( !any(grepl(\"^UN|SPEED|SAVE|QUIT\", Calls$Call)) ) {\n    first_call &lt;- data.frame(Call = \"SETNEWCHUNK(data)\", ID = 1, n = 1)\n    last_call &lt;- data.frame(Call = \"PLOT(data)\", ID = 1, n = 1)\n    Calls &lt;- rbind(first_call, Calls, last_call)\n  } \n  \n  Calls\n}\n\n\nCallshort &lt;- create_Calls(cl_splited)\nCallshort \n\n                         Call ID n\n1           SETNEWCHUNK(data)  1 1\n2                    CS(data)  1 1\n3 SP(-pi/5,-sin(pi/2)/2,data)  1 1\n4           SPC(\"black\",data)  1 1\n5                  PLOT(data)  1 1\n\n\n\n\n\n\nexpand_Repeats &lt;- function (Calls) {\n  IDmax &lt;- max(Calls$ID)\n  if (IDmax == 1) {\n    return(as.vector(Calls$Call))\n  } \n  while (IDmax &gt; 1){\n    \n    dfm &lt;- data.frame(\n      Call = character(),\n      ID = integer(),\n      n = integer(),\n      stringsAsFactors = FALSE\n      )\n    \n    rID &lt;- range(which(Calls$ID == IDmax))\n    n &lt;- Calls$n[rID[1]] \n    middle &lt;- (rID[1] + 1):rID[2]\n    \n    for (i in 1:n) {\n      dfm_sub &lt;- Calls[middle, ] %&gt;%\n        mutate(Call = gsub(\"\\\\(n\\\\)\", i, Call))\n      dfm &lt;- rbind(dfm,dfm_sub)\n      }\n    dfm$ID &lt;- Calls$ID[rID[1]-1]\n    dfm$n &lt;- Calls$n[rID[1]-1]\n    \n    before &lt;- 1:(rID[1] - 1)\n    dfb &lt;- Calls[before, ]\n    \n    after &lt;- (rID[2] + 1):nrow(Calls)\n    dfa &lt;- Calls[after, ]\n    \n    Calls &lt;- rbind(dfb,dfm,dfa)\n    IDmax &lt;- max(Calls$ID)\n  }\n  return(as.vector(Calls$Call[Calls$Call != \"\"]))\n}\n\n\nCalls &lt;- expand_Repeats(Callshort)\nCalls\n\n[1] \"SETNEWCHUNK(data)\"           \"CS(data)\"                   \n[3] \"SP(-pi/5,-sin(pi/2)/2,data)\" \"SPC(\\\"black\\\",data)\"        \n[5] \"PLOT(data)\"                 \n\n\n\n\n\n\nrun_prompt &lt;- function (Prompt, data) {\n  Prompt_splited &lt;- breakup_String(Prompt)\n  Callshort &lt;- create_Calls(Prompt_splited)\n  Calls &lt;- expand_Repeats(Callshort)\n  for (i in 1:length(Calls)){\n    data &lt;- eval(parse(text = as.character(Calls[i])))\n    }\n  data\n}"
  },
  {
    "objectID": "LOGO/Hubi_Logo_V3.14.html#helper-functions",
    "href": "LOGO/Hubi_Logo_V3.14.html#helper-functions",
    "title": "Logo with Gimmicks",
    "section": "",
    "text": "Initializing the game\n\nnew_field &lt;- function (size) {\n  dir_path &lt;- here(\"LOGO\",\"temp\")\n  chunk &lt;- 0\n  pos &lt;- 1\n  heading &lt;- 0\n  turtle &lt;- TRUE\n  turtle_color &lt;- \"red\"\n  path_color &lt;- \"blue\"\n  speed &lt;- 50\n  path &lt;- data.frame(chunk = 1,\n                     x = 0, y = 0, rad = 0, \n                     path_color = \"transparent\",\n                     turtle = turtle,\n                     turtle_color = turtle_color)\n  field &lt;- NULL\n  data &lt;- list(field_name = \"Logo\",\n               field_dir = file.path(dir_path),\n               size = abs(size),\n               chunk = chunk,\n               pos = pos,\n               heading = heading,\n               turtle = turtle,\n               turtle_color = turtle_color,\n               path_color = path_color,\n               speed = speed,\n               path = path)\n  data &lt;- SETNEWCHUNK(data)\n  data\n}\n\n\n\n\n\n record_path &lt;- function (data, \n                          chunk = NULL,\n                          x = NULL, \n                          y = NULL, \n                          rad = NULL, \n                          path_color = NULL, \n                          turtle = NULL,\n                          turtle_color = NULL) {\n   \n   temp &lt;- data$pos\n   n &lt;- max(lengths(list(chunk, x, y, rad, path_color, turtle, turtle_color)))\n   \n   template &lt;- data$path[temp, ]\n   newrows &lt;- template[rep(1, n), ]\n   \n   if (!is.null(chunk)) newrows$chunk &lt;- chunk\n   if (!is.null(x)) newrows$x &lt;- x\n   if (!is.null(y)) newrows$y &lt;- y\n   if (!is.null(rad)) newrows$rad &lt;- rad\n   if (!is.null(path_color)) newrows$path_color &lt;- path_color\n   if (!is.null(turtle)) newrows$turtle &lt;- turtle\n   if (!is.null(turtle_color)) newrows$turtle_color &lt;- turtle_color\n   \n   data$path &lt;- rbind(data$path, newrows)\n   rownames(data$path) &lt;- NULL\n   data$pos &lt;- nrow(data$path)\n   data\n}"
  },
  {
    "objectID": "LOGO/Hubi_Logo_V3.14.html#plot-functions",
    "href": "LOGO/Hubi_Logo_V3.14.html#plot-functions",
    "title": "Logo with Gimmicks",
    "section": "",
    "text": "plot_field &lt;- function (data, stat = NULL) {\n  if(is.null(stat)) stat &lt;- nrow(data$path)\n  maxpath &lt;- ceiling(max(abs(data$path[1:stat,c(\"x\",\"y\")])) * 1.11)\n  data$size &lt;- max(c(data$size, maxpath))\n  png_name &lt;- here(data$field_dir, paste0(data$field_name, stat, \".png\"))\n  png(png_name, width = 600, height = 600, res = 150)\n  par(mar = c(0, 0, 0, 0),\n      xaxs = \"i\", yaxs = \"i\")\n  plot.new()\n  plot.window(xlim = c(-data$size, data$size),\n              ylim = c(-data$size, data$size),\n              asp = 1)\n  box()\n  data\n}\n\n\n\n\n\nplot_path &lt;- function (data, stat = NULL) {\n  if(is.null(stat)) stat &lt;- nrow(data$path)\n  if (stat &gt; 1) {\n     for (i in 2:stat) {\n       segments(x0 = data$path$x[i-1], y0 = data$path$y[i-1],\n                x1 = data$path$x[i], y1 = data$path$y[i],\n                col = data$path$path_color[i], lwd = 2)\n     }\n  }\n  data\n}\n\n\n\n\n\nplot_turtle &lt;- function (data, stat = NULL) {\n  if(is.null(stat)) stat &lt;- nrow(data$path)\n  show &lt;-  data$path$turtle[stat]\n  if (show) {\n    symbols(x = data$path$x[stat],\n        y = data$path$y[stat],\n        circles = 0.02 * data$size,\n        inches = FALSE,\n        fg = NA,\n        bg = data$path$turtle_color[stat],\n        add = TRUE)\n    arrow_length &lt;- 0.1 * data$size\n    angle &lt;- data$path$rad[stat]\n    arrows(data$path$x[stat],\n           data$path$y[stat],\n           data$path$x[stat] + cos(angle) * arrow_length,\n           data$path$y[stat] + sin(angle) * arrow_length,\n           col = data$path$turtle_color[stat],\n           code = 2,\n           length = 0.1,\n           angle = 20,\n           lwd = 2)\n  }\n  dev.off()\n  data\n}\n\n\n\n\n\nplot_stat &lt;- function (data, stat = NULL) {\n  if(is.null(stat)) stat &lt;- nrow(data$path)\n  data &lt;- plot_field(data, stat)\n  data &lt;- plot_path(data, stat)\n  data &lt;- plot_turtle(data, stat)\n}\n\n\n\n\n\nclear_png &lt;- function (data) {\n  png_files &lt;- list.files(path = data$field_dir, \n                          pattern = \"\\\\.png$\", \n                          full.names = TRUE)\n  file.remove(png_files)\n}\n\n\nsave_png &lt;- function (data, chunk) {\n  if (chunk) {\n    Range &lt;- range(which(data$path$chunk == max(data$chunk)))\n    rmin &lt;- max(2,Range[1])\n    rmax &lt;- Range[2]\n    } else {\n      rmin &lt;- 2\n      rmax &lt;- nrow(data$path)\n    }\n  step &lt;- data$speed/(rmax-rmin)\n  step &lt;- pmin(pmax(step, 1/100), 1)\n  Seq0 &lt;- seq(from = 0, to = 1, by = step)\n  plot_seq &lt;- qbeta(Seq0, shape1 = 0.15, shape2 = 0.2)\n  plot_seq &lt;- (rmax - rmin) * plot_seq + rmin\n  plot_seq &lt;- round(plot_seq)\n  plot_seq &lt;- unique(plot_seq)\n\n  for (i in plot_seq) {\n      plot_stat(data, stat = i)\n  }\n}\n\n\nPLOT &lt;- function (data, chunk = TRUE) {\n  clear_png(data)\n  save_png(data, chunk = chunk)\n  png_files &lt;- list.files(path = data$field_dir, \n                          pattern = \"\\\\.png$\", \n                          full.names = TRUE)\n  png_files &lt;- png_files[order(as.numeric(gsub(\"\\\\D\", \"\", png_files)))]\n  img_list &lt;- lapply(png_files, image_read) \n  animation &lt;- image_animate(image_join(img_list), \n                             fps = 10, , loop = 1,\n                             optimize = TRUE) \n  image_write(animation, here(\"LOGO\",\"temp\",\"Output.gif\"))\n  clear_png(data)\n  data\n}"
  },
  {
    "objectID": "LOGO/Hubi_Logo_V3.14.html#application",
    "href": "LOGO/Hubi_Logo_V3.14.html#application",
    "title": "Logo with Gimmicks",
    "section": "",
    "text": "run_LOGO &lt;- function (string) {\n  file_path &lt;- here(\"LOGO\",\"temp\",\"Logo.rds\")\n  if (!dir.exists(here(\"LOGO\",\"temp\"))) {\n    dir.create(here(\"LOGO\", \"temp\"), showWarnings = FALSE)\n    }\n  if (file.exists(file_path)) {\n    data &lt;- readRDS(file_path)\n    } else {\n      data &lt;- new_field(5)\n    }\n  data &lt;- run_prompt(string, data)\n  if (!is.null(data)) {\n    saveRDS(data, file_path)\n  }\n}"
  },
  {
    "objectID": "LOGO/Hubi_Logo_V3.14.html#example-from-the-homepage",
    "href": "LOGO/Hubi_Logo_V3.14.html#example-from-the-homepage",
    "title": "Logo with Gimmicks",
    "section": "Example from the homepage",
    "text": "Example from the homepage\nwith some fancy shadow and color effects\n\nrun_LOGO(\"CS SP [-pi/5] [-Sin(PI/2)/2] sPc [black]\")\nrun_LOGO(\"REPEAT 20 [RepeaT 180 [FD 1 RT 2] RT 18]\")\nrun_LOGO(\"SPEED 100\")\nrun_LOGO(\"Home SpC [gREEN] StC [blue]\")\nrun_LOGO(\"REPEaT 20.1 [rEPEAT 180 [fD 1 RT 2] RT 18]\")\nrun_LOGO(\"UndoChunk\")\nrun_LOGO(\"SpC [blue] StC [green]\")\nrun_LOGO(\"REPEaT 5 [rEPEAT 180 [fD 1 RT 2] RT 72]\")\nrun_LOGO(\"SpC [green] StC [red] rt 18\")\nrun_LOGO(\"REPEaT 5 [rEPEAT 180 [fD 1 RT 2] RT 72]\")\nrun_LOGO(\"SpC [yellow] rt 18\")\nrun_LOGO(\"REPEaT 5 [rEPEAT 180 [fD 1 RT 2] RT 72]\")\nrun_LOGO(\"SpC [red] rt 18 ht\")\nrun_LOGO(\"REPEaT 5 [rEPEAT 360 [fD 0.5 RT 1] RT 72]\")"
  },
  {
    "objectID": "LOGO/Hubi_Logo_V3.14.html#working-output",
    "href": "LOGO/Hubi_Logo_V3.14.html#working-output",
    "title": "Logo with Gimmicks",
    "section": "Working Output",
    "text": "Working Output"
  },
  {
    "objectID": "LOGO/Hubi_Logo_V3.14.html#saved-output",
    "href": "LOGO/Hubi_Logo_V3.14.html#saved-output",
    "title": "Logo with Gimmicks",
    "section": "Saved Output",
    "text": "Saved Output\nyou can also save the output (Plot and path) for using and analyzing it later\n\nrun_LOGO(\"SPEED 1 saVe [Logo01]\")"
  },
  {
    "objectID": "LOGO/Hubi_Logo_V3.14.html#exercise-1",
    "href": "LOGO/Hubi_Logo_V3.14.html#exercise-1",
    "title": "Logo with Gimmicks",
    "section": "Exercise 1:",
    "text": "Exercise 1:\n\nrun_LOGO(\"CS\")\nrun_LOGO(\"REPEAT 80 [FD [N*2] RT 90]\")\nrun_LOGO(\"undo\")\nrun_LOGO(\"REPEAT 80 [FD [N*2^(N/40)] RT 90]\")\n\n\nWorking Output\n\n\n\nSaved Output\n\nrun_LOGO(\"SPEED 1 saVe [Logo02]\")"
  },
  {
    "objectID": "LOGO/Hubi_Logo_V3.14.html#exercise-2",
    "href": "LOGO/Hubi_Logo_V3.14.html#exercise-2",
    "title": "Logo with Gimmicks",
    "section": "Exercise 2:",
    "text": "Exercise 2:\n\nrun_LOGO(\"CS REPEAT 50 [ FD [n * 5]  RIGHT 144 ]\")\n\n\nWorking Output\n\n\n\nSaved Output\n\nrun_LOGO(\"SPEED 1 saVe [Logo03]\")"
  },
  {
    "objectID": "LOGO/Hubi_Logo_V3.14.html#exercise-3",
    "href": "LOGO/Hubi_Logo_V3.14.html#exercise-3",
    "title": "Logo with Gimmicks",
    "section": "Exercise 3:",
    "text": "Exercise 3:\n\nrun_LOGO(\"CS REPEAT 150 [ FD [n * 2]  RT 91 ]\")\n\n\nWorking Output\n\n\n\nSaved Output\n\nrun_LOGO(\"SPEED 1 saVe [Logo04]\")"
  }
]