{
  "hash": "546a13574b9394e9b3a69df40e8516dc",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"HubiAtGit\"\nauthor: \"Hubert Baechli\"\ndate: sys.date()\n---\n\n\n\n\n\n## Programming exercise\n\nIn contrast to the simple method described below, the first exercise should calculates our own PI.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npi\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.141593\n```\n\n\n:::\n:::\n\n\n\nThe following is a step-by-step guide to putting the first programming skills from the lesson into practice.\n\n## Basic idea\n\nAs Ven showed in the first lesson...\n\n... if we throw thousands of random placed darts into a square field, the number of darts that fall into the enclosed circle should represent the area of that circle in relation to the area of the square.\n\nIn the following we will try to confirm this with our own programming skills.\n\n### 1. Step\n\nGeneration of a random position for a single dart within a square. The square extends from -1 to +1 in the X-direction, as well as in the Y-direction.\\\nUse a random number generator for a uniform distribution and save the result in the two variables x and y (GAP are placeholder)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- runif(n = GAP, min = GAP, max = GAP)\ny <- GAP\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n\n### 2. Step\n\nNow calculate the distance from this position to the center. You can use the following simplified formula for our chosen square\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndist <- x**2 + y**2\nprint(dist)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.041785\n```\n\n\n:::\n:::\n\n\n\n### 3. Step\n\nCreate a decision rule and print \"inside\" if the point is inside the circle or \"outside\" if it is not.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (dist <= GAP) {\n  GAP\n} else {\n  GAP\n}\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n\n### 4. Step\n\nCreate now a loop (use for or while statement) and execute the code from steps 1 to 3 within it. You should get something like that now\n\n*Hint: Use may 10 iteration for the beginning*\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"inside\"\n[1] \"inside\"\n[1] \"inside\"\n[1] \"inside\"\n[1] \"inside\"\n[1] \"inside\"\n[1] \"outside\"\n[1] \"inside\"\n[1] \"inside\"\n[1] \"inside\"\n```\n\n\n:::\n:::\n\n\n\n### 5. Step\n\nCopy now the code from Step 4 and modify it in a way that instead of outputting a result for each point, it sums up the number of \"insides\".\n\nUse something like that,\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn_insides <- 0\nn_insides <- n_insides + 1\nprint(n_insides)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n\n\nor more elegant write the results in a vector.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv_insides <- rep(x = 0, 10)\nv_insides[2] <- 1\nprint(v_insides)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 0 1 0 0 0 0 0 0 0 0\n```\n\n\n:::\n:::\n\n\n\nIf you use 1000 iteration you should became such a number\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 782\n```\n\n\n:::\n:::\n\n\n\n## Final Step\n\nAs the final step, you now need to calculate PI from your result and compare it with the real one ;-)\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(selfmade_pi)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.128\n```\n\n\n:::\n\n```{.r .cell-code}\nif (selfmade_pi == pi) {\n  print(\"YOU ARE UNBELIEFABLE\")\n} else {\n  print(\"Try more iterations !!! (or try the function round)\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Try more iterations !!! (or try the function round)\"\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}