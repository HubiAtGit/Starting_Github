{
  "hash": "dae8f20639b70ca4debc00d52d33145c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Logo with Gimmicks\"\nauthor: \"Hubert Baechli\"\ndate: \"2025-04-16\"\n---\n\n\n\n\n\n# Logo\n\n**Goal:** Programming a simple language with R\n\nLogo goes back much earlier than the Apple II, it was developed in 1967 by Cynthia Solomon, Wally Feurzig, and Seymour Papert. That's five years before C and 24 years before Python! The three worked at Bolt, Beranek, and Newman (BBN), famous for all kinds of other computing history. BBN built the first Interface Message Processors (early routers) in 1968 for the ARPANET, which would evolve into the modern internet. [...learn more](https://learn.adafruit.com/program-logo-on-an-apple-ii/what-is-logo)\n\n## Basic Commands\n\nImplementing the basic commands [see \"Hello Turtle\"](https://learn.adafruit.com/program-logo-on-an-apple-ii/hello-turtle)\n\n### CLEARSCREEN (CS)\n\nClear the screen and initializing the field\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nCLEARSCREEN <- function (data) {\n  data <- new_field(5)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nCS <- function (data) {\n  CLEARSCREEN(data)\n}\n```\n:::\n\n\n\n### HIDETURTLE (HT)\n\nDon't show the turtle cursor.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nHIDETURTLE <- function (data) {\n  data$turtle <- FALSE\n  data <- record_path(data, turtle = data$turtle)\n  data\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nHT <- function (data) {\n  HIDETURTLE(data)\n}\n```\n:::\n\n\n\n### SHOWTURTLE (ST)\n\nShow the turtle cursor.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSHOWTURTLE <- function (data) {\n  data$turtle <- TRUE\n  data <- record_path(data, turtle = data$turtle)\n  data\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nST <- function (data) {\n  SHOWTURTLE(data)\n}\n```\n:::\n\n\n\n### FORWARD (FD)\n\nMove forward *steps*.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nFORWARD <- function (step, data) {\n  angle <- data$path$rad[data$pos] \n  x0 <- data$path$x[data$pos]\n  y0 <- data$path$y[data$pos]\n  \n  max_step <- 1\n  n_step <- abs(step)%/%(max_step * 1.5) + 1\n  Seq0 <- seq(from = 0, to = 1, by = 1/n_step)\n  Seq0 <- Seq0[-1]\n  steps <- qbeta(Seq0, shape1 = 0.15, shape2 = 0.2)\n  steps <- steps * step\n  \n  x1 <- x0 + cos(angle) * steps\n  y1 <- y0 + sin(angle) * steps\n  data <- record_path(data,  x = x1, y = y1, \n                      path_color = data$path_color)\n  data\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nFD <- function (steps, data) {\n  FORWARD(steps, data)\n}\n```\n:::\n\n\n\n### BACK (BK)\n\nMove back *steps*.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nBACK <- function (steps, data) {\n  FORWARD(-steps, data)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nBK <- function (steps, data) {\n  BACK(steps, data)\n}\n```\n:::\n\n\n\n### LEFT (LT)\n\nTurn left this many degrees. Negative degrees work too, they'll turn it right.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nLEFT <- function (degs, data) {\n  data$heading <- data$heading + degs\n  data <- record_path(data, rad = data$heading * pi / 180)\n  data\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nLT <- function (degs, data) {\n  LEFT(degs, data)\n}\n```\n:::\n\n\n\n### RIGHT (RT)\n\nTurn right this many degrees.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRIGHT <- function (degs, data) {\n  LEFT(-degs, data)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nRT <- function (degs, data) {\n  RIGHT(degs, data)\n}\n```\n:::\n\n\n\n### SETHEADING (SH)\n\nTurn to an absolute heading of *degrees*.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSETHEADING <- function (deg, data) {\n  data$heading <- deg\n  data <- record_path(data, rad = data$heading * pi / 180)\n  data\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nSH <- function (deg, data) {\n  SETHEADING(deg, data)\n}\n```\n:::\n\n\n\n### SETPOS (SP)\n\nSet the position to *x, y* coordinates. These are Cartesian, so 0,0 is the middle of the screen.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSETPOS <- function (x1, y1, data) {\n  data <- record_path(data, x = x1, y = y1, \n                      path_color = \"transparent\")\n  data\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nSP <- function (x1, y1, data) {\n  SETPOS(x1, y1, data)\n}\n```\n:::\n\n\n\n### HOME\n\nMove back to the home position.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nHOME <- function (data) {\n  SETPOS(x1 = 0, y1 = 0, data)\n}\n```\n:::\n\n\n\n### SETPOSX (SPX)\n\nSet the horizontal position to *x*.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSETPOSX <- function (x1, data) {\n  SETPOS(x1, y1 = data$path$y[data$pos], data)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nSPX <- function (x1, data) {\n  SETPOSX(x1, data)\n}\n```\n:::\n\n\n\n### SETPOSY (SPY)\n\nSet the vertical position to *y*.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSETPOSY <- function (y1, data) {\n  SETPOS(x1 = data$path$x[data$pos], y1, data)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nSPY <- function (y1, data) {\n  SETPOSY(y1, data)\n}\n```\n:::\n\n\n\n## Gimmicks\n\n### SETPATHCOLOR (SPC)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSETPATHCOLOR <- function (path_color, data) {\n  data$path_color <- path_color\n  data <- record_path(data, path_color = data$path_color)\n  data\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nSPC <- function (path_color, data) {\n  SETPATHCOLOR(path_color, data)\n}\n```\n:::\n\n\n\n### SETTURTLECOLOR (STC)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSETTURTLECOLOR <- function (turtle_color, data) {\n  data$turtle_color <- turtle_color\n  data <- record_path(data, turtle_color = data$turtle_color)\n  data\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nSTC <- function (turtle_color, data) {\n  SETTURTLECOLOR(turtle_color, data)\n}\n```\n:::\n\n\n\n### SETNEWCHUNK (SNC)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSETNEWCHUNK <- function (data) {\n  data$chunk <- data$chunk + 1\n  data <- record_path(data, chunk = data$chunk)\n  data\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nSNC <- function (data) {\n  SETNEWCHUNK(data)\n}\n```\n:::\n\n\n\n### UNDOCHUNK (UNDO)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nUNDOCHUNK <- function (data) {\n  last_chunk <- max(data$path$chunk)\n  if (last_chunk > 2) {\n    data$path <- data$path[data$path$chunk != last_chunk,]\n  } else {\n    data <- CLEARSCREEN(data) \n    data <- REPLOT(data)\n    return(data)\n  }\n  \n  data$chunk <- max(data$path$chunk)\n  data$pos <- nrow(data$path)\n  data$heading <- data$path$rad[data$pos] * 180 / pi \n  data$turtle <- data$path$turtle[data$pos]\n  data$turtle_color <- data$path$turtle_color[data$pos]\n  \n  last_pos <- data$pos\n  while (data$path$path_color[last_pos] == \"transparent\" && last_pos > 0) {\n    last_pos <- last_pos - 1\n  }\n  if (last_pos == 1) {\n    data$path_color <- \"blue\"\n  } else {\n    data$path_color <- data$path$path_color[last_pos]\n  }\n  \n  data <- REPLOT(data)\n  \n  data\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nUNDO <- function (data) {\n  UNDOCHUNK(data)\n}\n```\n:::\n\n\n\n### SETSPEED (SPEED)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSETSPEED <- function (speed, data) {\n  speed <- pmax(speed, 1)\n  speed <- round(speed)\n  data$speed <- speed\n  #data <- REPLOT(data)\n  data\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nSPEED <- function (speed, data) {\n  SETSPEED(speed, data)\n}\n```\n:::\n\n\n\n### REPLOT\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nREPLOT <- function (data, chunk = FALSE) {\n  PLOT(data, chunk)\n}\n```\n:::\n\n\n\n### SAVEPATH (SAVE)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSAVEPATH <- function (name, data) {\n  name_raw <- paste0(name, \".rds\")\n  name_gif <- paste0(name, \".gif\")\n  data <- REPLOT(data)\n  saveRDS(data$path, here(\"LOGO\", name_raw))\n  file.copy(from = here(\"LOGO\", \"temp\", \"output.gif\"), \n            to = here(\"LOGO\", name_gif), \n            overwrite = TRUE)\n  data\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nSAVE <- function (name, data) {\n  SAVEPATH(name, data)\n}\n```\n:::\n\n\n\n### QUITLOGO (QUIT)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nQUITLOGO <- function (data) {\n  suppressWarnings(unlink(here(\"LOGO\", \"temp\"), recursive = TRUE))\n  data <- NULL\n  data\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nQUIT <- function (data) {\n  QUITLOGO(data)\n}\n```\n:::\n\n\n\n## Parsing Prompts\n\n### Clean strings\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclean_prompt <- function (Prompt) {\n  Prompt <- gsub(\"([^a-zA-Z0-9])\", \" \\\\1 \", Prompt)\n  Prompt <- gsub(\"\\\\s+\", \" \", Prompt)\n  Prompt <- gsub(\"-\\\\s+(?=\\\\d)\", \"-\", Prompt, perl = TRUE)\n  Prompt <- gsub(\"\\\\s*\\\\.\\\\s*\", \".\", Prompt)\n  Prompt <- gsub(\"\\\\s*_\\\\s*\", \"_\", Prompt)\n  Prompt <- trimws(Prompt)\n  Prompt\n}\n```\n:::\n\n\n\n### Analyzing and spliting Code\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbreakup_String <- function(String) {\n  cl_String <- clean_prompt(String)\n  split_String <- strsplit(cl_String, \" \")[[1]]\n  df <- data.frame(Code = split_String)\n  \n  n_func <- 0\n  df$ID_Func <- rep(0, nrow(df))\n  \n  n_par <- 0\n  df$ID_Par <- rep(0, nrow(df))\n  \n  ID <- 1\n  df$ID_Repeat <- rep(0, nrow(df))\n  \n  brakets <- data.frame(ID = ID,\n                        Status = TRUE,\n                        n = 1)\n  \n  level <- brakets$ID[max(which(brakets$Status == TRUE))]\n  \n  df$n_Repeat <- rep(1, nrow(df))\n  \n  is_par_braket <- FALSE\n  \n  i <- 1\n  imax <- nrow(df) + 1\n  \n  while ( i < imax ) {\n    \n    if (df$Code[i] == \"[\") {\n        n_par <- n_par + 1\n        is_par_braket <- TRUE\n        i <- i + 1\n        next\n    }\n    \n    if (is_par_braket) {\n      \n      if (df$Code[i] == \"]\") {\n        is_par_braket <- FALSE\n        i <- i + 1\n        next\n      }\n      \n      if ( !grepl(\"[A-Za-z]\", df$Code[i])) {\n        df$ID_Func[i] <- n_func\n        df$ID_Par[i] <- n_par\n        df$ID_Repeat[i] <- brakets$ID[brakets$ID == level]\n        df$n_Repeat[i] <- brakets$n[brakets$ID == level]\n        i <- i + 1\n        next\n      } else {\n        inLower <- tolower(df$Code[i])\n        if (inLower == \"n\") {\n          df$Code[i] <- paste0(\"(\",inLower,\")\")\n        } else if (inLower %in% colors()) {\n          df$Code[i] <- paste0(shQuote(inLower))\n        } else if (exists(inLower)) {\n          df$Code[i] <- inLower\n        }  else {\n          df$Code[i] <- paste0(shQuote(df$Code[i]))\n        }\n        df$ID_Func[i] <- n_func\n        df$ID_Par[i] <- n_par\n        df$ID_Repeat[i] <- brakets$ID[brakets$ID == level]\n        df$n_Repeat[i] <- brakets$n[brakets$ID == level]\n        i <- i + 1\n        next\n      }\n      \n    } else {\n      \n      if (df$Code[i] == \"]\") {\n      brakets$Status[brakets$ID == level] <- FALSE\n      level <- brakets$ID[max(which(brakets$Status == TRUE))]\n      i <- i + 1\n      next\n      }\n      \n      if ( !grepl(\"[A-Za-z]\", df$Code[i]) ) {\n        n_par <- n_par + 1\n        df$ID_Func[i] <- n_func\n        df$ID_Par[i] <- n_par\n        df$ID_Repeat[i] <- brakets$ID[brakets$ID == level]\n        df$n_Repeat[i] <- brakets$n[brakets$ID == level]\n        i <- i + 1\n        next\n      } else {\n        inCaps <- toupper(df$Code[i])\n        \n        is_LOGO_func <- exists(inCaps) && is.function(get(inCaps))\n        if (is_LOGO_func) {\n          n_func <- n_func + 1\n          df$Code[i] <- inCaps\n        }\n      \n        is_repeat <- inCaps == \"REPEAT\"\n        if (is_repeat) {\n          n_func <- n_func + 1\n          ID <- ID + 1\n          i = i + 2\n          df$Code[i] <- inCaps\n          brakets <- rbind(brakets,\n                           data.frame(ID = ID, \n                                      Status = TRUE, \n                                      n = round(as.numeric(df$Code[i - 1]))))\n          level <- brakets$ID[max(which(brakets$Status == TRUE))]\n        }\n        df$ID_Func[i] <- n_func\n        df$ID_Repeat[i] <- brakets$ID[brakets$ID == level]\n        df$n_Repeat[i] <- brakets$n[brakets$ID == level]\n        i <- i + 1\n        next\n      }\n    }\n\n  }\n  return(df[df$ID_Func != 0,])\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nCodeLine <- \"CS SP [-pi/5] [-Sin(PI/2)/2] sPc [black]\"\ncl_splited <-breakup_String(CodeLine)\ncl_splited\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      Code ID_Func ID_Par ID_Repeat n_Repeat\n1       CS       1      0         1        1\n2       SP       2      0         1        1\n4        -       2      1         1        1\n5       pi       2      1         1        1\n6        /       2      1         1        1\n7        5       2      1         1        1\n10       -       2      2         1        1\n11     sin       2      2         1        1\n12       (       2      2         1        1\n13      pi       2      2         1        1\n14       /       2      2         1        1\n15       2       2      2         1        1\n16       )       2      2         1        1\n17       /       2      2         1        1\n18       2       2      2         1        1\n20     SPC       3      0         1        1\n22 \"black\"       3      3         1        1\n```\n\n\n:::\n:::\n\n\n\n### Create Calls\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncreate_Calls <- function (splited) {\n  Calls <- splited %>%\n    group_by(ID_Func, ID_Par) %>%\n    mutate(Func_Par = ifelse(ID_Par > 0,1,0),\n           Code = ifelse(first(ID_Par) > 0, \n                         paste0(Code, collapse = \"\"),\n                         Code)) %>%\n    ungroup() %>%\n    distinct(Code, ID_Func, ID_Par, Func_Par, .keep_all = TRUE) %>%\n    \n    group_by(ID_Func, Func_Par) %>%\n    mutate(Code = ifelse(first(Func_Par) > 0, \n                         paste0(c(Code,\"data)\"), collapse = \",\"), \n                         Code)) %>%\n    ungroup() %>%\n    distinct(Code, ID_Func, Func_Par, .keep_all = TRUE) %>%\n  \n    group_by(ID_Func) %>%\n    mutate(Code = ifelse(n() > 1,\n                         paste0(Code, collapse = \"(\"),\n                         paste0(Code, \"(data)\"))) %>%\n    ungroup() %>%\n    distinct(Code, ID_Func, .keep_all = TRUE) %>%\n    rename(Call = Code, ID = ID_Repeat, n = n_Repeat ) %>%\n    select(Call,ID, n)\n  \n  if ( !any(grepl(\"^UN|SPEED|SAVE|QUIT\", Calls$Call)) ) {\n    first_call <- data.frame(Call = \"SETNEWCHUNK(data)\", ID = 1, n = 1)\n    last_call <- data.frame(Call = \"PLOT(data)\", ID = 1, n = 1)\n    Calls <- rbind(first_call, Calls, last_call)\n  } \n  \n  Calls\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nCallshort <- create_Calls(cl_splited)\nCallshort \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                         Call ID n\n1           SETNEWCHUNK(data)  1 1\n2                    CS(data)  1 1\n3 SP(-pi/5,-sin(pi/2)/2,data)  1 1\n4           SPC(\"black\",data)  1 1\n5                  PLOT(data)  1 1\n```\n\n\n:::\n:::\n\n\n\n### Expand Repeats\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexpand_Repeats <- function (Calls) {\n  IDmax <- max(Calls$ID)\n  if (IDmax == 1) {\n    return(as.vector(Calls$Call))\n  } \n  while (IDmax > 1){\n    \n    dfm <- data.frame(\n      Call = character(),\n      ID = integer(),\n      n = integer(),\n      stringsAsFactors = FALSE\n      )\n    \n    rID <- range(which(Calls$ID == IDmax))\n    n <- Calls$n[rID[1]] \n    middle <- (rID[1] + 1):rID[2]\n    \n    for (i in 1:n) {\n      dfm_sub <- Calls[middle, ] %>%\n        mutate(Call = gsub(\"\\\\(n\\\\)\", i, Call))\n      dfm <- rbind(dfm,dfm_sub)\n      }\n    dfm$ID <- Calls$ID[rID[1]-1]\n    dfm$n <- Calls$n[rID[1]-1]\n    \n    before <- 1:(rID[1] - 1)\n    dfb <- Calls[before, ]\n    \n    after <- (rID[2] + 1):nrow(Calls)\n    dfa <- Calls[after, ]\n    \n    Calls <- rbind(dfb,dfm,dfa)\n    IDmax <- max(Calls$ID)\n  }\n  return(as.vector(Calls$Call[Calls$Call != \"\"]))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nCalls <- expand_Repeats(Callshort)\nCalls\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"SETNEWCHUNK(data)\"           \"CS(data)\"                   \n[3] \"SP(-pi/5,-sin(pi/2)/2,data)\" \"SPC(\\\"black\\\",data)\"        \n[5] \"PLOT(data)\"                 \n```\n\n\n:::\n:::\n\n\n\n### Run Calls\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_prompt <- function (Prompt, data) {\n  Prompt_splited <- breakup_String(Prompt)\n  Callshort <- create_Calls(Prompt_splited)\n  Calls <- expand_Repeats(Callshort)\n  for (i in 1:length(Calls)){\n    data <- eval(parse(text = as.character(Calls[i])))\n    }\n  data\n}\n```\n:::\n\n\n\n## Helper Functions\n\n### New field\n\nInitializing the game\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_field <- function (size) {\n  dir_path <- here(\"LOGO\",\"temp\")\n  chunk <- 0\n  pos <- 1\n  heading <- 0\n  turtle <- TRUE\n  turtle_color <- \"red\"\n  path_color <- \"blue\"\n  speed <- 50\n  path <- data.frame(chunk = 1,\n                     x = 0, y = 0, rad = 0, \n                     path_color = \"transparent\",\n                     turtle = turtle,\n                     turtle_color = turtle_color)\n  field <- NULL\n  data <- list(field_name = \"Logo\",\n               field_dir = file.path(dir_path),\n               size = abs(size),\n               chunk = chunk,\n               pos = pos,\n               heading = heading,\n               turtle = turtle,\n               turtle_color = turtle_color,\n               path_color = path_color,\n               speed = speed,\n               path = path)\n  data <- SETNEWCHUNK(data)\n  data\n}\n```\n:::\n\n\n\n### Record Path\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n record_path <- function (data, \n                          chunk = NULL,\n                          x = NULL, \n                          y = NULL, \n                          rad = NULL, \n                          path_color = NULL, \n                          turtle = NULL,\n                          turtle_color = NULL) {\n   \n   temp <- data$pos\n   n <- max(lengths(list(chunk, x, y, rad, path_color, turtle, turtle_color)))\n   \n   template <- data$path[temp, ]\n   newrows <- template[rep(1, n), ]\n   \n   if (!is.null(chunk)) newrows$chunk <- chunk\n   if (!is.null(x)) newrows$x <- x\n   if (!is.null(y)) newrows$y <- y\n   if (!is.null(rad)) newrows$rad <- rad\n   if (!is.null(path_color)) newrows$path_color <- path_color\n   if (!is.null(turtle)) newrows$turtle <- turtle\n   if (!is.null(turtle_color)) newrows$turtle_color <- turtle_color\n   \n   data$path <- rbind(data$path, newrows)\n   rownames(data$path) <- NULL\n   data$pos <- nrow(data$path)\n   data\n}\n```\n:::\n\n\n\n## Plot Functions\n\n### Field\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_field <- function (data, stat = NULL) {\n  if(is.null(stat)) stat <- nrow(data$path)\n  maxpath <- ceiling(max(abs(data$path[1:stat,c(\"x\",\"y\")])) * 1.11)\n  data$size <- max(c(data$size, maxpath))\n  png_name <- here(data$field_dir, paste0(data$field_name, stat, \".png\"))\n  png(png_name, width = 600, height = 600, res = 150)\n  par(mar = c(0, 0, 0, 0),\n      xaxs = \"i\", yaxs = \"i\")\n  plot.new()\n  plot.window(xlim = c(-data$size, data$size),\n              ylim = c(-data$size, data$size),\n              asp = 1)\n  box()\n  data\n}\n```\n:::\n\n\n\n### Path\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_path <- function (data, stat = NULL) {\n  if(is.null(stat)) stat <- nrow(data$path)\n  if (stat > 1) {\n     for (i in 2:stat) {\n       segments(x0 = data$path$x[i-1], y0 = data$path$y[i-1],\n                x1 = data$path$x[i], y1 = data$path$y[i],\n                col = data$path$path_color[i], lwd = 2)\n     }\n  }\n  data\n}\n```\n:::\n\n\n\n### Turtle\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_turtle <- function (data, stat = NULL) {\n  if(is.null(stat)) stat <- nrow(data$path)\n  show <-  data$path$turtle[stat]\n  if (show) {\n    symbols(x = data$path$x[stat],\n        y = data$path$y[stat],\n        circles = 0.02 * data$size,\n        inches = FALSE,\n        fg = NA,\n        bg = data$path$turtle_color[stat],\n        add = TRUE)\n    arrow_length <- 0.1 * data$size\n    angle <- data$path$rad[stat]\n    arrows(data$path$x[stat],\n           data$path$y[stat],\n           data$path$x[stat] + cos(angle) * arrow_length,\n           data$path$y[stat] + sin(angle) * arrow_length,\n           col = data$path$turtle_color[stat],\n           code = 2,\n           length = 0.1,\n           angle = 20,\n           lwd = 2)\n  }\n  dev.off()\n  data\n}\n```\n:::\n\n\n\n### Stat\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_stat <- function (data, stat = NULL) {\n  if(is.null(stat)) stat <- nrow(data$path)\n  data <- plot_field(data, stat)\n  data <- plot_path(data, stat)\n  data <- plot_turtle(data, stat)\n}\n```\n:::\n\n\n\n### PLOT (Animation)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclear_png <- function (data) {\n  png_files <- list.files(path = data$field_dir, \n                          pattern = \"\\\\.png$\", \n                          full.names = TRUE)\n  file.remove(png_files)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsave_png <- function (data, chunk) {\n  if (chunk) {\n    Range <- range(which(data$path$chunk == max(data$chunk)))\n    rmin <- max(2,Range[1])\n    rmax <- Range[2]\n    } else {\n      rmin <- 2\n      rmax <- nrow(data$path)\n    }\n  step <- data$speed/(rmax-rmin)\n  step <- pmin(pmax(step, 1/100), 1)\n  Seq0 <- seq(from = 0, to = 1, by = step)\n  plot_seq <- qbeta(Seq0, shape1 = 0.15, shape2 = 0.2)\n  plot_seq <- (rmax - rmin) * plot_seq + rmin\n  plot_seq <- round(plot_seq)\n  plot_seq <- unique(plot_seq)\n\n  for (i in plot_seq) {\n      plot_stat(data, stat = i)\n  }\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nPLOT <- function (data, chunk = TRUE) {\n  clear_png(data)\n  save_png(data, chunk = chunk)\n  png_files <- list.files(path = data$field_dir, \n                          pattern = \"\\\\.png$\", \n                          full.names = TRUE)\n  png_files <- png_files[order(as.numeric(gsub(\"\\\\D\", \"\", png_files)))]\n  img_list <- lapply(png_files, image_read) \n  animation <- image_animate(image_join(img_list), \n                             fps = 10, , loop = 1,\n                             optimize = TRUE) \n  image_write(animation, here(\"LOGO\",\"temp\",\"Output.gif\"))\n  clear_png(data)\n  data\n}\n```\n:::\n\n\n\n## Application\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_LOGO <- function (string) {\n  file_path <- here(\"LOGO\",\"temp\",\"Logo.rds\")\n  if (!dir.exists(here(\"LOGO\",\"temp\"))) {\n    dir.create(here(\"LOGO\", \"temp\"), showWarnings = FALSE)\n    }\n  if (file.exists(file_path)) {\n    data <- readRDS(file_path)\n    } else {\n      data <- new_field(5)\n    }\n  data <- run_prompt(string, data)\n  if (!is.null(data)) {\n    saveRDS(data, file_path)\n  }\n}\n```\n:::\n\n\n\n# Run Game\n\n## Example from the homepage\n\nwith some fancy shadow and color effects\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_LOGO(\"CS SP [-pi/5] [-Sin(PI/2)/2] sPc [black]\")\nrun_LOGO(\"REPEAT 20 [RepeaT 180 [FD 1 RT 2] RT 18]\")\nrun_LOGO(\"SPEED 100\")\nrun_LOGO(\"Home SpC [gREEN] StC [blue]\")\nrun_LOGO(\"REPEaT 20.1 [rEPEAT 180 [fD 1 RT 2] RT 18]\")\nrun_LOGO(\"UndoChunk\")\nrun_LOGO(\"SpC [blue] StC [green]\")\nrun_LOGO(\"REPEaT 5 [rEPEAT 180 [fD 1 RT 2] RT 72]\")\nrun_LOGO(\"SpC [green] StC [red] rt 18\")\nrun_LOGO(\"REPEaT 5 [rEPEAT 180 [fD 1 RT 2] RT 72]\")\nrun_LOGO(\"SpC [yellow] rt 18\")\nrun_LOGO(\"REPEaT 5 [rEPEAT 180 [fD 1 RT 2] RT 72]\")\nrun_LOGO(\"SpC [red] rt 18 ht\")\nrun_LOGO(\"REPEaT 5 [rEPEAT 360 [fD 0.5 RT 1] RT 72]\")\n```\n:::\n\n\n\n## Working Output\n\n![](temp/Output.gif)\n\n## Saved Output\n\nyou can also save the output (Plot and path) for using and analyzing it later\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_LOGO(\"SPEED 1 saVe [Logo01]\")\n```\n:::\n\n\n\n![](Logo01.gif)\n\n# Other Exercises\n\nSince `n` is also used as a loop variable in my program, handling many other exercises doesn't pose any issues.\n\n<https://softwareprogramming4kids.com/loops-in-logo/>\n\n## Exercise 1:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_LOGO(\"CS\")\nrun_LOGO(\"REPEAT 80 [FD [N*2] RT 90]\")\nrun_LOGO(\"undo\")\nrun_LOGO(\"REPEAT 80 [FD [N*2^(N/40)] RT 90]\")\n```\n:::\n\n\n\n### Working Output\n\n![](temp/Output.gif)\n\n### Saved Output\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_LOGO(\"SPEED 1 saVe [Logo02]\")\n```\n:::\n\n\n\n![](Logo02.gif)\n\n## Exercise 2:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_LOGO(\"CS REPEAT 50 [ FD [n * 5]  RIGHT 144 ]\")\n```\n:::\n\n\n\n### Working Output\n\n![](temp/Output.gif)\n\n### Saved Output\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_LOGO(\"SPEED 1 saVe [Logo03]\")\n```\n:::\n\n\n\n![](Logo03.gif)\n\n## Exercise 3:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_LOGO(\"CS REPEAT 150 [ FD [n * 2]  RT 91 ]\")\n```\n:::\n\n\n\n### Working Output\n\n![](temp/Output.gif)\n\n### Saved Output\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_LOGO(\"SPEED 1 saVe [Logo04]\")\n```\n:::\n\n\n\n![](Logo04.gif)\n\n# Quit LOGO\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_LOGO(\"QUIT\")\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}