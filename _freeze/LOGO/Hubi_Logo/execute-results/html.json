{
  "hash": "94dc80d9d9e9e5eb006932339d22ee23",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Logo with Gimmicks\"\nauthor: \"Hubert Baechli\"\ndate: \"04-15-2025\"\n---\n\n\n\n\n\n# Logo\n\n**Goal:** Programming a simple language with R\n\nLogo goes back much earlier than the Apple II, it was developed in 1967 by Cynthia Solomon, Wally Feurzig, and Seymour Papert. That's five years before C and 24 years before Python! The three worked at Bolt, Beranek, and Newman (BBN), famous for all kinds of other computing history. BBN built the first Interface Message Processors (early routers) in 1968 for the ARPANET, which would evolve into the modern internet. [...learn more](https://learn.adafruit.com/program-logo-on-an-apple-ii/what-is-logo)\n\n## Basic Commands\n\nImplementing the basic commands [see \"Hello Turtle\"](https://learn.adafruit.com/program-logo-on-an-apple-ii/hello-turtle)\n\n### CLEARSCREEN (CS)\n\nClear the screen and initializing the field\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nCLEARSCREEN <- function () {\n  rm(list = ls(envir = LOGO), envir = LOGO)\n  new_field(5)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nCS <- function () {\n  CLEARSCREEN()\n}\n```\n:::\n\n\n\n### HIDETURTLE (HT)\n\nDon't show the turtle cursor.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nHIDETURTLE <- function () {\n  LOGO$data$turtle <- FALSE\n  record_path(turtle = LOGO$data$turtle)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nHT <- function () {\n  HIDETURTLE()\n}\n```\n:::\n\n\n\n### SHOWTURTLE (ST)\n\nShow the turtle cursor.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSHOWTURTLE <- function () {\n  LOGO$data$turtle <- TRUE\n  record_path(turtle = LOGO$data$turtle)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nST <- function () {\n  SHOWTURTLE()\n}\n```\n:::\n\n\n\n### FORWARD (FD)\n\nMove forward *steps*.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nFORWARD <- function (step) {\n  angle <- LOGO$data$path$rad[LOGO$data$pos] \n  x0 <- LOGO$data$path$x[LOGO$data$pos]\n  y0 <- LOGO$data$path$y[LOGO$data$pos]\n  \n  max_step <- 1\n  n_step <- abs(step)%/%(max_step * 1.5) + 1\n  Seq0 <- seq(from = 0, to = 1, by = 1/n_step)\n  Seq0 <- Seq0[-1]\n  steps <- qbeta(Seq0, shape1 = 0.15, shape2 = 0.2)\n  steps <- steps * step\n  \n  x1 <- x0 + cos(angle) * steps\n  y1 <- y0 + sin(angle) * steps\n  \n  record_path(x = x1, y = y1, path_color = LOGO$data$path_color)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nFD <- function (step) {\n  FORWARD(step)\n}\n```\n:::\n\n\n\n### BACK (BK)\n\nMove back *steps*.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nBACK <- function (steps) {\n  FORWARD(-steps)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nBK <- function (steps) {\n  BACK(steps)\n}\n```\n:::\n\n\n\n### LEFT (LT)\n\nTurn left this many degrees. Negative degrees work too, they'll turn it right.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nLEFT <- function (degs) {\n  LOGO$data$heading <- LOGO$data$heading + degs\n  record_path(rad = LOGO$data$heading * pi / 180)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nLT <- function (degs) {\n  LEFT(degs)\n}\n```\n:::\n\n\n\n### RIGHT (RT)\n\nTurn right this many degrees.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRIGHT <- function (degs) {\n  LEFT(-degs)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nRT <- function (degs) {\n  RIGHT(degs)\n}\n```\n:::\n\n\n\n### SETHEADING (SH)\n\nTurn to an absolute heading of *degrees*.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSETHEADING <- function (deg) {\n  LOGO$data$heading <- deg\n  record_path(rad = LOGO$data$heading * pi / 180)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nSH <- function (deg) {\n  SETHEADING(deg)\n}\n```\n:::\n\n\n\n### SETPOS (SP)\n\nSet the position to *x, y* coordinates. These are Cartesian, so 0,0 is the middle of the screen.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSETPOS <- function (x1, y1) {\n  record_path(x = x1, y = y1, path_color = \"transparent\")\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nSP <- function (x1, y1) {\n  SETPOS(x1, y1)\n}\n```\n:::\n\n\n\n### HOME\n\nMove back to the home position.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nHOME <- function () {\n  SETPOS(x1 = 0, y1 = 0)\n}\n```\n:::\n\n\n\n### SETPOSX (SPX)\n\nSet the horizontal position to *x*.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSETPOSX <- function (x1) {\n  SETPOS(x1, y1 = LOGO$data$path$y[LOGO$data$pos])\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nSPX <- function (x1) {\n  SETPOSX(x1)\n}\n```\n:::\n\n\n\n### SETPOSY (SPY)\n\nSet the vertical position to *y*.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSETPOSY <- function (y1) {\n  SETPOS(x1 = LOGO$data$path$x[LOGO$data$pos], y1)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nSPY <- function (y1) {\n  SETPOSY(y1)\n}\n```\n:::\n\n\n\n## Gimmicks\n\n### SETPATHCOLOR (SPC)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSETPATHCOLOR <- function (path_color) {\n  LOGO$data$path_color <- path_color\n  record_path(path_color = LOGO$data$path_color)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nSPC <- function (path_color) {\n  SETPATHCOLOR(path_color)\n}\n```\n:::\n\n\n\n### SETTURTLECOLOR (STC)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSETTURTLECOLOR <- function (turtle_color) {\n  LOGO$data$turtle_color <- turtle_color\n  record_path(turtle_color = LOGO$data$turtle_color)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nSTC <- function (turtle_color) {\n  SETTURTLECOLOR(turtle_color)\n}\n```\n:::\n\n\n\n### SETNEWCHUNK (SNC)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSETNEWCHUNK <- function () {\n  LOGO$data$chunk <- LOGO$data$chunk + 1\n  record_path(chunk = LOGO$data$chunk)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nSNC <- function () {\n  SETNEWCHUNK()\n}\n```\n:::\n\n\n\n### UNDOCHUNK (UNDO)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nUNDOCHUNK <- function () {\n  last_chunk <- max(LOGO$data$path$chunk)\n  if (last_chunk > 1) {\n    LOGO$data$path <- LOGO$data$path[LOGO$data$path$chunk != last_chunk,]\n  } else {\n    CLEARSCREEN() \n  }\n  \n  LOGO$data$chunk <- max(LOGO$data$path$chunk)\n  LOGO$data$pos <- nrow(LOGO$data$path)\n  LOGO$data$heading <- LOGO$data$path$rad[LOGO$data$pos] * 180 / pi \n  LOGO$data$turtle <- LOGO$data$path$turtle[LOGO$data$pos]\n  LOGO$data$turtle_color <- LOGO$data$path$turtle_color[LOGO$data$pos]\n  \n  last_pos <- LOGO$data$pos\n  while (LOGO$data$path$path_color[last_pos] == \"transparent\" && last_pos > 0) {\n    last_pos <- last_pos - 1\n  }\n  if (last_pos == 0) {\n    LOGO$data$path_color <- \"blue\"\n  } else {\n    LOGO$data$path_color <- LOGO$data$path$path_color[last_pos]\n  }\n  REPLOT()\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nUNDO <- function () {\n  UNDOCHUNK()\n}\n```\n:::\n\n\n\n### SETSPEED (SPEED)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSETSPEED <- function (speed) {\n  speed <- pmax(speed, 1)\n  speed <- round(speed)\n  LOGO$data$speed <- speed\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nSPEED <- function (speed) {\n  SETSPEED(speed)\n}\n```\n:::\n\n\n\n### REPLOT\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nREPLOT <- function (chunk = FALSE) {\n  PLOT(chunk)\n}\n```\n:::\n\n\n\n### SAVEPATH (SAVE)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSAVEPATH <- function (name) {\n  name_gif <- paste0(name, \".gif\")\n  REPLOT()\n  file.copy(from = file.path(tempdir(), \"Logo_Output.gif\"), \n            to = here(\"LOGO\", name_gif), \n            overwrite = TRUE)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nSAVE <- function (name) {\n  SAVEPATH(name)\n}\n```\n:::\n\n\n\n### QUITLOGO (QUIT)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nQUITLOGO <- function () {\n  if (exists(\"LOGO\", envir = .GlobalEnv)) {\n  rm(LOGO, envir = .GlobalEnv)\n}\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nQUIT <- function () {\n  QUITLOGO()\n}\n```\n:::\n\n\n\n## Parsing Prompts\n\n### Clean strings\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclean_prompt <- function (Prompt) {\n  Prompt <- gsub(\"([^a-zA-Z0-9])\", \" \\\\1 \", Prompt)\n  Prompt <- gsub(\"\\\\s+\", \" \", Prompt)\n  Prompt <- gsub(\"-\\\\s+(?=\\\\d)\", \"-\", Prompt, perl = TRUE)\n  Prompt <- gsub(\"\\\\s*\\\\.\\\\s*\", \".\", Prompt)\n  Prompt <- gsub(\"\\\\s*_\\\\s*\", \"_\", Prompt)\n  Prompt <- trimws(Prompt)\n  Prompt\n}\n```\n:::\n\n\n\n### Analyzing and spliting Code\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbreakup_String <- function(String) {\n  cl_String <- clean_prompt(String)\n  split_String <- strsplit(cl_String, \" \")[[1]]\n  df <- data.frame(Code = split_String)\n  \n  n_func <- 0\n  df$ID_Func <- rep(0, nrow(df))\n  \n  n_par <- 0\n  df$ID_Par <- rep(0, nrow(df))\n  \n  ID <- 1\n  df$ID_Repeat <- rep(0, nrow(df))\n  \n  brakets <- data.frame(ID = ID,\n                        Status = TRUE,\n                        n = 1)\n  \n  level <- brakets$ID[max(which(brakets$Status == TRUE))]\n  \n  df$n_Repeat <- rep(1, nrow(df))\n  \n  is_par_braket <- FALSE\n  \n  i <- 1\n  imax <- nrow(df) + 1\n  \n  while ( i < imax ) {\n    \n    if (df$Code[i] == \"[\") {\n        n_par <- n_par + 1\n        is_par_braket <- TRUE\n        i <- i + 1\n        next\n    }\n    \n    if (is_par_braket) {\n      \n      if (df$Code[i] == \"]\") {\n        is_par_braket <- FALSE\n        i <- i + 1\n        next\n      }\n      \n      if ( !grepl(\"[A-Za-z]\", df$Code[i])) {\n        df$ID_Func[i] <- n_func\n        df$ID_Par[i] <- n_par\n        df$ID_Repeat[i] <- brakets$ID[brakets$ID == level]\n        df$n_Repeat[i] <- brakets$n[brakets$ID == level]\n        i <- i + 1\n        next\n      } else {\n        inLower <- tolower(df$Code[i])\n        if (inLower == \"n\") {\n          df$Code[i] <- paste0(\"(\",inLower,\")\")\n        } else if (inLower %in% colors()) {\n          df$Code[i] <- paste0(\"'\",inLower,\"'\")\n        } else if (exists(inLower)) {\n          df$Code[i] <- inLower\n        }  else {\n          df$Code[i] <- paste0(\"'\",df$Code[i],\"'\")\n        }\n        df$ID_Func[i] <- n_func\n        df$ID_Par[i] <- n_par\n        df$ID_Repeat[i] <- brakets$ID[brakets$ID == level]\n        df$n_Repeat[i] <- brakets$n[brakets$ID == level]\n        i <- i + 1\n        next\n      }\n      \n    } else {\n      \n      if (df$Code[i] == \"]\") {\n      brakets$Status[brakets$ID == level] <- FALSE\n      level <- brakets$ID[max(which(brakets$Status == TRUE))]\n      i <- i + 1\n      next\n      }\n      \n      if ( !grepl(\"[A-Za-z]\", df$Code[i]) ) {\n        n_par <- n_par + 1\n        df$ID_Func[i] <- n_func\n        df$ID_Par[i] <- n_par\n        df$ID_Repeat[i] <- brakets$ID[brakets$ID == level]\n        df$n_Repeat[i] <- brakets$n[brakets$ID == level]\n        i <- i + 1\n        next\n      } else {\n        inCaps <- toupper(df$Code[i])\n        \n        is_LOGO_func <- exists(inCaps) && is.function(get(inCaps))\n        if (is_LOGO_func) {\n          n_func <- n_func + 1\n          df$Code[i] <- inCaps\n        }\n      \n        is_repeat <- inCaps == \"REPEAT\"\n        if (is_repeat) {\n          n_func <- n_func + 1\n          ID <- ID + 1\n          i = i + 2\n          df$Code[i] <- inCaps\n          brakets <- rbind(brakets,\n                           data.frame(ID = ID, \n                                      Status = TRUE, \n                                      n = round(as.numeric(df$Code[i - 1]))))\n          level <- brakets$ID[max(which(brakets$Status == TRUE))]\n        }\n        df$ID_Func[i] <- n_func\n        df$ID_Repeat[i] <- brakets$ID[brakets$ID == level]\n        df$n_Repeat[i] <- brakets$n[brakets$ID == level]\n        i <- i + 1\n        next\n      }\n    }\n\n  }\n  return(df[df$ID_Func != 0,])\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nCodeLine <- \"CS SP [-pi/5] [-Sin(PI/2)/2] sPc [black]\"\ncl_splited <-breakup_String(CodeLine)\ncl_splited\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      Code ID_Func ID_Par ID_Repeat n_Repeat\n1       CS       1      0         1        1\n2       SP       2      0         1        1\n4        -       2      1         1        1\n5       pi       2      1         1        1\n6        /       2      1         1        1\n7        5       2      1         1        1\n10       -       2      2         1        1\n11     sin       2      2         1        1\n12       (       2      2         1        1\n13      pi       2      2         1        1\n14       /       2      2         1        1\n15       2       2      2         1        1\n16       )       2      2         1        1\n17       /       2      2         1        1\n18       2       2      2         1        1\n20     SPC       3      0         1        1\n22 'black'       3      3         1        1\n```\n\n\n:::\n:::\n\n\n\n### Create Calls\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncreate_Calls <- function (splited) {\n  Calls <- splited %>%\n    group_by(ID_Func, ID_Par) %>%\n    mutate(Func_Par = ifelse(ID_Par > 0,1,0),\n           Code = ifelse(first(ID_Par) > 0, \n                         paste0(Code, collapse = \"\"),\n                         Code)) %>%\n    ungroup() %>%\n    distinct(Code, ID_Func, ID_Par, Func_Par, .keep_all = TRUE) %>%\n    \n    group_by(ID_Func, Func_Par) %>%\n    mutate(Code = ifelse(first(Func_Par) > 0, \n                         paste0(Code, collapse = \", \"), \n                         Code)) %>%\n    ungroup() %>%\n    distinct(Code, ID_Func, Func_Par, .keep_all = TRUE) %>%\n  \n    group_by(ID_Func) %>%\n    mutate(Code = ifelse(n() > 1,\n                         paste0(Code, collapse = \"(\"),\n                         paste0(Code, \"(\")),\n           Code = paste0(Code, \")\")) %>%\n    ungroup() %>%\n    distinct(Code, ID_Func, .keep_all = TRUE) %>%\n    rename(Call = Code, ID = ID_Repeat, n = n_Repeat ) %>%\n    select(Call,ID, n)\n  \n  if ( !any(grepl(\"^UN|SPEED|SAVE|QUIT\", Calls$Call)) ) {\n    first_call <- data.frame(Call = \"SETNEWCHUNK()\", ID = 1, n = 1)\n    last_call <- data.frame(Call = \"PLOT()\", ID = 1, n = 1)\n    Calls <- rbind(first_call, Calls, last_call)\n  } \n  \n  Calls\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nCallshort <- create_Calls(cl_splited)\nCallshort \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                     Call ID n\n1           SETNEWCHUNK()  1 1\n2                    CS()  1 1\n3 SP(-pi/5, -sin(pi/2)/2)  1 1\n4            SPC('black')  1 1\n5                  PLOT()  1 1\n```\n\n\n:::\n:::\n\n\n\n### Expand Repeats\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexpand_Repeats <- function (Calls) {\n  IDmax <- max(Calls$ID)\n  if (IDmax == 1) {\n    return(as.vector(Calls$Call))\n  } \n  while (IDmax > 1){\n    \n    dfm <- data.frame(\n      Call = character(),\n      ID = integer(),\n      n = integer(),\n      stringsAsFactors = FALSE\n      )\n    \n    rID <- range(which(Calls$ID == IDmax))\n    n <- Calls$n[rID[1]] \n    middle <- (rID[1] + 1):rID[2]\n    \n    for (i in 1:n) {\n      dfm_sub <- Calls[middle, ] %>%\n        mutate(Call = gsub(\"\\\\(n\\\\)\", i, Call))\n      dfm <- rbind(dfm,dfm_sub)\n      }\n    dfm$ID <- Calls$ID[rID[1]-1]\n    dfm$n <- Calls$n[rID[1]-1]\n    \n    before <- 1:(rID[1] - 1)\n    dfb <- Calls[before, ]\n    \n    after <- (rID[2] + 1):nrow(Calls)\n    dfa <- Calls[after, ]\n    \n    Calls <- rbind(dfb,dfm,dfa)\n    IDmax <- max(Calls$ID)\n  }\n  return(as.vector(Calls$Call[Calls$Call != \"\"]))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nCalls <- expand_Repeats(Callshort)\nCalls\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"SETNEWCHUNK()\"           \"CS()\"                   \n[3] \"SP(-pi/5, -sin(pi/2)/2)\" \"SPC('black')\"           \n[5] \"PLOT()\"                 \n```\n\n\n:::\n:::\n\n\n\n### Run Calls\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_prompt <- function (Prompt) {\n  Prompt_splited <- breakup_String(Prompt)\n  Callshort <- create_Calls(Prompt_splited)\n  Calls <- expand_Repeats(Callshort)\n  for (i in 1:length(Calls)){\n    eval(parse(text = as.character(Calls[i])))\n    }\n}\n```\n:::\n\n\n\n## Helper Functions\n\n### New field\n\nInitializing the game\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_field <- function (size) {\n  dir_path <- here(\"LOGO\", \"temp\")\n  chunk <- 1\n  pos <- 2\n  heading <- 0\n  turtle <- TRUE\n  turtle_color <- \"red\"\n  path_color <- \"blue\"\n  speed <- 50\n  path <- data.frame(\n    chunk = rep(1, pos),\n    x = rep(0, pos),\n    y = rep(0, pos),\n    rad = rep(0, pos),\n    path_color = rep(\"transparent\", pos),\n    turtle = c(FALSE, rep(turtle, pos - 1)),\n    turtle_color = rep(turtle_color, pos),\n    stringsAsFactors = FALSE\n  )\n  \n  LOGO$data <- list(\n    field_name = \"LOGO\",\n    field_dir = here(),\n    size = abs(size),\n    chunk = chunk,\n    pos = pos,\n    heading = heading,\n    turtle = turtle,\n    turtle_color = turtle_color,\n    path_color = path_color,\n    speed = speed,\n    path = path\n  )\n}\n```\n:::\n\n\n\n### Record Path\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n record_path <- function (chunk = NULL,\n                          x = NULL, \n                          y = NULL, \n                          rad = NULL, \n                          path_color = NULL, \n                          turtle = NULL,\n                          turtle_color = NULL) {\n   \n   temp <- LOGO$data$pos\n   n <- max(lengths(list(chunk, x, y, rad, path_color, turtle, turtle_color)))\n   \n   template <- LOGO$data$path[temp, ]\n   newrows <- template[rep(1, n), ]\n   \n   if (!is.null(chunk)) newrows$chunk <- chunk\n   if (!is.null(x)) newrows$x <- x\n   if (!is.null(y)) newrows$y <- y\n   if (!is.null(rad)) newrows$rad <- rad\n   if (!is.null(path_color)) newrows$path_color <- path_color\n   if (!is.null(turtle)) newrows$turtle <- turtle\n   if (!is.null(turtle_color)) newrows$turtle_color <- turtle_color\n   \n   LOGO$data$path <- rbind(LOGO$data$path, newrows)\n   rownames(LOGO$data$path) <- NULL\n   LOGO$data$pos <- nrow(LOGO$data$path)\n}\n```\n:::\n\n\n\n## Plot Functions\n\n### Field\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_field <- function (stat) {\n  maxpath <- ceiling(max(abs(LOGO$data$path[1:stat,c(\"x\",\"y\")])) * 1.11)\n  LOGO$data$size <- max(c(LOGO$data$size, maxpath), na.rm = TRUE)\n\n  par(mar = c(0, 0, 0, 0),\n      xaxs = \"i\", yaxs = \"i\")\n  plot.new()\n  plot.window(xlim = c(-LOGO$data$size, LOGO$data$size),\n              ylim = c(-LOGO$data$size, LOGO$data$size),\n              asp = 1)\n  box()\n}\n```\n:::\n\n\n\n### Path\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_path <- function (stat) {\n  if (stat > 1) {\n     for (i in 2:stat) {\n       segments(x0 = LOGO$data$path$x[i-1], y0 = LOGO$data$path$y[i-1],\n                x1 = LOGO$data$path$x[i], y1 = LOGO$data$path$y[i],\n                col = LOGO$data$path$path_color[i], lwd = 2)\n     }\n  }\n}\n```\n:::\n\n\n\n### Turtle\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_turtle <- function (stat) {\n  show <-  LOGO$data$path$turtle[stat]\n  if (show) {\n    symbols(x = LOGO$data$path$x[stat],\n        y = LOGO$data$path$y[stat],\n        circles = 0.02 * LOGO$data$size,\n        inches = FALSE,\n        fg = NA,\n        bg = LOGO$data$path$turtle_color[stat],\n        add = TRUE)\n    arrow_length <- 0.1 * LOGO$data$size\n    angle <- LOGO$data$path$rad[stat]\n    arrows(LOGO$data$path$x[stat],\n           LOGO$data$path$y[stat],\n           LOGO$data$path$x[stat] + cos(angle) * arrow_length,\n           LOGO$data$path$y[stat] + sin(angle) * arrow_length,\n           col = LOGO$data$path$turtle_color[stat],\n           code = 2,\n           length = 0.1,\n           angle = 20,\n           lwd = 2)\n  }\n}\n```\n:::\n\n\n\n### Stat\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_stat <- function (stat = NULL) {\n  if(is.null(stat)) stat <- nrow(LOGO$data$path)\n  \n  tmpfile <- tempfile(fileext = \".png\")\n  png(filename = tmpfile, width = 600, height = 600, res = 150)\n  \n  plot_field(stat)\n  plot_path(stat)\n  plot_turtle(stat)\n  \n  dev.off()\n  img <- image_read(tmpfile)\n  \n  unlink(tmpfile)\n\n  img\n\n}\n```\n:::\n\n\n\n### PLOT (Animation)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nPLOT <- function (chunk = TRUE) {\n  if (chunk) {\n    Range <- range(which(LOGO$data$path$chunk == max(LOGO$data$chunk)))\n    rmin <- max(2,Range[1])\n    rmax <- Range[2]\n    } else {\n      rmin <- 2\n      rmax <- nrow(LOGO$data$path)\n    }\n  step <- LOGO$data$speed/(rmax-rmin)\n  step <- pmin(pmax(step, 1/100), 1)\n  Seq0 <- seq(from = 0, to = 1, by = step)\n  plot_seq <- qbeta(Seq0, shape1 = 0.15, shape2 = 0.2)\n  plot_seq <- (rmax - rmin) * plot_seq + rmin\n  plot_seq <- round(plot_seq)\n  plot_seq <- unique(plot_seq)\n  \n  img_list <- lapply(plot_seq, function(i) plot_stat(i))\n  Logo_Output <- image_animate(image_join(img_list), \n                             fps = 10, loop = 1,\n                             optimize = TRUE) \n  \n  gif_path <- file.path(tempdir(), \"Logo_Output.gif\")\n  image_write(Logo_Output, path = gif_path)\n  \n  print(Logo_Output)\n\n  invisible(Logo_Output)\n}\n```\n:::\n\n\n\n## Application\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_LOGO <- function(string) {\n  if (!exists(\"LOGO\", envir = .GlobalEnv)) {\n    assign(\"LOGO\", new.env(), envir = .GlobalEnv)\n    LOGO <- get(\"LOGO\", envir = .GlobalEnv)\n    new_field(5)\n  } else {\n    LOGO <- get(\"LOGO\", envir = .GlobalEnv)\n  }\n  run_prompt(string)\n}\n```\n:::\n\n\n\n# Run Game\n\n## Example from the homepage\n\nwith some fancy shadow and color effects\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_LOGO(\"CS SP [-pi/5] [-Sin(PI/2)/2] sPc [black]\")\nrun_LOGO(\"REPEAT 20 [RepeaT 180 [FD 1 RT 2] RT 18]\")\nrun_LOGO(\"SPEED 100\")\nrun_LOGO(\"Home SpC [gREEN] StC [blue]\")\nrun_LOGO(\"REPEaT 20.1 [rEPEAT 180 [fD 1 RT 2] RT 18]\")\nrun_LOGO(\"UndoChunk\")\nrun_LOGO(\"SpC [blue] StC [green]\")\nrun_LOGO(\"REPEaT 5 [rEPEAT 180 [fD 1 RT 2] RT 72]\")\nrun_LOGO(\"SpC [green] StC [red] rt 18\")\nrun_LOGO(\"REPEaT 5 [rEPEAT 180 [fD 1 RT 2] RT 72]\")\nrun_LOGO(\"SpC [yellow] rt 18\")\nrun_LOGO(\"REPEaT 5 [rEPEAT 180 [fD 1 RT 2] RT 72]\")\nrun_LOGO(\"SpC [red] rt 18 ht\")\nrun_LOGO(\"REPEaT 5 [rEPEAT 360 [fD 0.5 RT 1] RT 72]\")\n```\n:::\n\n\n\n## Saved Output\n\nyou can also save the output (Plot and path) for using and analyzing it later\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_LOGO(\"SPEED 1 saVe [Logo01]\")\n```\n:::\n\n\n\n![](Logo01.gif)\n\n# Other Exercises\n\nSince `n` is also used as a loop variable in my program, handling many other exercises doesn't pose any issues.\n\n<https://softwareprogramming4kids.com/loops-in-logo/>\n\n## Exercise 1:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_LOGO(\"CS\")\nrun_LOGO(\"REPEAT 80 [FD [N*2] RT 90]\")\nrun_LOGO(\"undo\")\nrun_LOGO(\"REPEAT 80 [FD [N*2^(N/40)] RT 90]\")\n```\n:::\n\n\n\n### Saved Output\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_LOGO(\"SPEED 1 saVe [Logo02]\")\n```\n:::\n\n\n\n![](Logo02.gif)\n\n## Exercise 2:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_LOGO(\"CS REPEAT 50 [ FD [n * 5]  RIGHT 144 ]\")\n```\n:::\n\n\n\n### Saved Output\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_LOGO(\"SPEED 1 saVe [Logo03]\")\n```\n:::\n\n\n\n![](Logo03.gif)\n\n## Exercise 3:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_LOGO(\"CS REPEAT 150 [ FD [n * 2]  RT 91 ]\")\n```\n:::\n\n\n\n### Saved Output\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_LOGO(\"SPEED 1 saVe [Logo04]\")\n```\n:::\n\n\n\n![](Logo04.gif)\n\n# Quit LOGO\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_LOGO(\"QUIT\")\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}